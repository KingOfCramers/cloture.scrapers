FUNCTION  <lambda>7()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/tsserver.vim line 16
Called 9 times
Total time:   0.006817
 Self time:   0.000125

count  total (s)   self (s)
    9   0.006812   0.000120 return ale#node#FindExecutable(b, 'javascript_tsserver', [       'node_modules/.bin/tsserver',   ])

FUNCTION  <SNR>144_HandleExit()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 186
Called 6 times
Total time:   0.026588
 Self time:   0.000585

count  total (s)   self (s)
    6              0.000023     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    6              0.000010     if empty(l:buffer_info)
                                    return
    6              0.000003     endif
                            
    6              0.000009     let l:linter = a:job_info.linter
    6              0.000009     let l:executable = a:job_info.executable
    6              0.000009     let l:next_chain_index = a:job_info.next_chain_index
                            
                                " Remove this job from the list.
    6   0.000125   0.000073     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    6   0.000224   0.000080     if ale#util#InSandbox()
                                    return
    6              0.000002     endif
                            
    6              0.000049     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    6              0.000002     endif
                            
    6              0.000021     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   l:executable,   l:linter,   l:next_chain_index,   a:output,)
                            
                                    call s:RunJob(l:command, l:options)
                            
                                    return
    6              0.000002     endif
                            
    6              0.000003     try
    6   0.010649   0.000112         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    6              0.000003     endtry
                            
    6   0.015338   0.000068     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>162_syntax_at()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 26
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return synIDattr(synID(a:lnum, a:col, 1), 'name')

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 115
Called 102 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
  102              0.000139   if s:is_vim
                                return a:client['channel']
  102              0.000053   endif
  102              0.000163   return a:client['chan_id']

FUNCTION  1()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 14
Called 3 times
Total time:   0.000146
 Self time:   0.000117

count  total (s)   self (s)
    3              0.000006     let l:prependWorkingDir = 0
                            
    3   0.000054   0.000025     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
    3              0.000002     else
    3              0.000023         let l:prependWorkingDir = a:pathStr !~# '^/'
    3              0.000002     endif
                            
    3              0.000005     let l:result = a:pathStr
                            
    3              0.000003     if l:prependWorkingDir
                                    let l:result = getcwd()
                            
                                    if l:result[-1:] ==# s:Path.Slash()
                                        let l:result = l:result . a:pathStr
                                    else
                                        let l:result = l:result . s:Path.Slash() . a:pathStr
                                    endif
    3              0.000001     endif
                            
    3              0.000003     return l:result

FUNCTION  3()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 47
Called 34 times
Total time:   0.001940
 Self time:   0.001407

count  total (s)   self (s)
   34   0.000586   0.000269     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
   34              0.000028     if self.isExecutable
    2   0.000054   0.000015         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
   34              0.000013     endif
                            
   34              0.000080     let self._bookmarkNames = []
   34   0.000400   0.000223     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
   34              0.000037     endfor
   34              0.000084     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
   34              0.000013     endif
                            
   34              0.000025     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
   34              0.000012     endif
                            
   34              0.000023     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
   34              0.000011     endif

FUNCTION  4()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 74
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000031     if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
                                    return a:line
    2              0.000001     else
    2              0.000004         return a:line . g:NERDTreeNodeDelimiter
                                endif

FUNCTION  ale#job#Stop()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim line 346
Called 3 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000007     if !has_key(s:job_map, a:job_id)
                                    return
    3              0.000001     endif
                            
    3              0.000009     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
    3              0.000036         silent! call jobstop(a:job_id)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
    3              0.000001     endif

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 42
Called 2 times
Total time:   0.000222
 Self time:   0.000075

count  total (s)   self (s)
                                " Unmark a file as being changed outside of Vim after we try to check it.
    2              0.000015     call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
    2   0.000055   0.000022     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
    2   0.000132   0.000018         call ale#Queue(0, 'lint_file', a:buffer)
    2              0.000014     endif

FUNCTION  <SNR>49_collect()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 769
Called 1 time
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
    1              0.000001   try
    1              0.000117     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
    1              0.000002   finally
    2              0.000006     for tf in values(a:temps)
    1              0.000108       silent! call delete(tf)
    2              0.000003     endfor
    1              0.000001   endtry

FUNCTION  <SNR>146_parseJSON()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 97
Called 6 times
Total time:   0.000836
 Self time:   0.000836

count  total (s)   self (s)
    6              0.000009     let l:parsed = []
                            
   12              0.000033     for l:line in a:lines
    6              0.000004         try
    6              0.000469             let l:parsed = extend(l:parsed, json_decode(l:line))
                                    catch
    6              0.000004         endtry
   12              0.000010     endfor
                            
    6              0.000017     if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
    6              0.000003     endif
                            
    6              0.000013     let l:errors = l:parsed[0]['messages']
                            
    6              0.000007     if empty(l:errors)
    3              0.000002         return []
    3              0.000001     endif
                            
    3              0.000003     let l:output = []
                            
    6              0.000007     for l:error in l:errors
    3              0.000019         let l:obj = ({   'lnum': get(l:error, 'line', 0),   'text': get(l:error, 'message', ''),   'type': 'E',})
                            
    3              0.000006         if get(l:error, 'severity', 0) is# 1
                                        let l:obj.type = 'W'
    3              0.000001         endif
                            
    3              0.000006         if has_key(l:error, 'ruleId')
    3              0.000005             let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
    3              0.000005             if !empty(l:code)
    3              0.000005                 let l:obj.code = l:code
    3              0.000001             endif
    3              0.000001         endif
                            
    3              0.000005         if has_key(l:error, 'column')
    3              0.000005             let l:obj.col = l:error['column']
    3              0.000001         endif
                            
    3              0.000008         if has_key(l:error, 'endColumn')
    3              0.000006             let l:obj.end_col = l:error['endColumn'] - 1
    3              0.000001         endif
                            
    3              0.000005         if has_key(l:error, 'endLine')
    3              0.000005             let l:obj.end_lnum = l:error['endLine']
    3              0.000001         endif
                            
    3              0.000008         call add(l:output, l:obj)
    6              0.000012     endfor
                            
    3              0.000003     return l:output

FUNCTION  rainbow_main#gen_config()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow_main.vim line 78
Called 2 times
Total time:   0.000292
 Self time:   0.000235

count  total (s)   self (s)
    2              0.000011 	let g = exists('g:rainbow_conf')? g:rainbow_conf : {}
                            	"echom 'g:rainbow_conf:' string(g)
    2              0.000006 	let s = get(g, 'separately', {})
                            	"echom 'g:rainbow_conf.separately:' string(s)
    2              0.000028 	let dft_conf = extend(copy(s:rainbow_conf), g) | unlet dft_conf.separately
                            	"echom 'default config options:' string(dft_conf)
    2              0.000007 	let dx_conf = s:rainbow_conf.separately['*']
                            	"echom 'default star config:' string(dx_conf)
    2              0.000006 	let ds_conf = get(s:rainbow_conf.separately, a:ft, dx_conf)
                            	"echom 'default separately config:' string(ds_conf)
    2              0.000004 	let ux_conf = get(s, '*', ds_conf)
                            	"echom 'user star config:' string(ux_conf)
    2              0.000004 	let us_conf = get(s, a:ft, ux_conf)
                            	"echom 'user separately config:' string(us_conf)
    2   0.000047   0.000039 	let af_conf = (s:eq(us_conf, 'default') ? ds_conf : us_conf)
                            	"echom 'almost finally config:' string(af_conf)
    2   0.000016   0.000010 	if s:eq(af_conf, 0)
                            		return 0
    2              0.000001 	else
    2              0.000052 		let conf = extend(extend({'syn_name_prefix': substitute(a:ft, '\v\A+(\a)', '\u\1', 'g').'Rainbow'}, dft_conf), af_conf)
    2   0.000096   0.000053 		let conf.cycle = (has('gui_running') || (has('termguicolors') && &termguicolors)) ? s:lcm(len(conf.guifgs), len(conf.guis)) : s:lcm(len(conf.ctermfgs), len(conf.cterms))
    2              0.000002 		return conf
                            	endif

FUNCTION  ale#fixers#prettier#Fix()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/prettier.vim line 17
Called 3 times
Total time:   0.013445
 Self time:   0.000075

count  total (s)   self (s)
    3   0.013444   0.000073     return ale#semver#RunWithVersionCheck(   a:buffer,   ale#fixers#prettier#GetExecutable(a:buffer),   '%e --version',   function('ale#fixers#prettier#ApplyFixForVersion'),)

FUNCTION  ale#semver#GTE()
    Defined: ~/.vim/plugged/ale/autoload/ale/semver.vim line 62
Called 6 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    6              0.000012     if empty(a:lhs)
                                    return 0
    6              0.000003     endif
                            
    6              0.000010     if a:lhs[0] > a:rhs[0]
    6              0.000004         return 1
                                elseif a:lhs[0] == a:rhs[0]
                                    if a:lhs[1] > a:rhs[1]
                                        return 1
                                    elseif a:lhs[1] == a:rhs[1]
                                        return get(a:lhs, 2) >= get(a:rhs, 2)
                                    endif
                                endif
                            
                                return 0

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 476
Called 12 times
Total time:   0.011126
 Self time:   0.002487

count  total (s)   self (s)
   12              0.000040     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   24              0.000155     for l:original_filetype in split(a:original_filetypes, '\.')
   12   0.001243   0.000192         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   12   0.000642   0.000182         let l:linter_names = s:GetLinterNames(l:original_filetype)
   12   0.007323   0.000194         let l:all_linters = ale#linter#GetAll(l:filetype)
   12              0.000020         let l:filetype_linters = []
                            
   12              0.000053         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
   12              0.000022             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
   12              0.000014         endif
                            
   12              0.000042         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   24              0.000050     endfor
                            
   12              0.000021     let l:name_list = []
   12              0.000018     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   93              0.000100     for l:linter in reverse(l:possibly_duplicated_linters)
   81              0.000183         if index(l:name_list, l:linter.name) < 0
   81              0.000188             call add(l:name_list, l:linter.name)
   81              0.000162             call add(l:combined_linters, l:linter)
   81              0.000036         endif
   93              0.000047     endfor
                            
   12              0.000025     return reverse(l:combined_linters)

FUNCTION  ale#fixers#eslint#ApplyFixForVersion()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/eslint.vim line 36
Called 3 times
Total time:   0.008060
 Self time:   0.000396

count  total (s)   self (s)
    3   0.003844   0.000066     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
    3   0.000073   0.000031     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
                                " Use the configuration file from the options, if configured.
    3              0.000034     if l:options =~# '\v(^| )-c|(^| )--config'
                                    let l:config = ''
                                    let l:has_config = 1
    3              0.000003     else
    3   0.003726   0.000042         let l:config = ale#handlers#eslint#FindConfig(a:buffer)
    3              0.000012         let l:has_config = !empty(l:config)
    3              0.000003     endif
                            
    3              0.000004     if !l:has_config
                                    return 0
    3              0.000002     endif
                            
                                " Use --fix-to-stdout with eslint_d
    3              0.000039     if l:executable =~# 'eslint_d$' && ale#semver#GTE(a:version, [3, 19, 0])
                                    return {   'command': ale#node#Executable(a:buffer, l:executable)       . ale#Pad(l:options)       . ' --stdin-filename %s --stdin --fix-to-stdout',   'process_with': 'ale#fixers#eslint#ProcessEslintDOutput',}
    3              0.000002     endif
                            
                                " 4.9.0 is the first version with --fix-dry-run
    3   0.000066   0.000041     if ale#semver#GTE(a:version, [4, 9, 0])
    3   0.000205   0.000071         return {   'command': ale#node#Executable(a:buffer, l:executable)       . ale#Pad(l:options)       . ' --stdin-filename %s --stdin --fix-dry-run --format=json',   'process_with': 'ale#fixers#eslint#ProcessFixDryRunOutput',}
                                endif
                            
                                return {   'command': ale#node#Executable(a:buffer, l:executable)       . ale#Pad(l:options)       . (!empty(l:config) ? ' -c ' . ale#Escape(l:config) : '')       . ' --fix %t',   'read_temporary_file': 1,}

FUNCTION  <SNR>131_GetPair()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 71
Called 1 time
Total time:   0.000064
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000063   0.000022     return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)

FUNCTION  <SNR>75_NERDTreeCacheDirtyDir()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 126
Called 2 times
Total time:   0.000166
 Self time:   0.000142

count  total (s)   self (s)
                                " cache dirty dir
    2   0.000050   0.000026     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
    2              0.000007     if l:dirtyPath =~# '\.\./.*'
                                    return
    2              0.000001     endif
    2              0.000017     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
    5              0.000042     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
    3              0.000012         let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
    3              0.000019         let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
    5              0.000005     endwhile

FUNCTION  repeat#wrap()
    Defined: ~/.vim/plugged/vim-repeat/autoload/repeat.vim line 132
Called 2 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    2              0.000013     let preserve = (g:repeat_tick == b:changedtick)
    2              0.000013     call feedkeys((a:count ? a:count : '').a:command, 'n')
    2              0.000075     exe (&foldopen =~# 'undo\|all' ? 'norm! zv' : '')
    2              0.000003     if preserve
                                    let g:repeat_tick = b:changedtick
    2              0.000002     endif

FUNCTION  <SNR>131_Nat()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 157
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003   return a:int * (a:int > 0)

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 829
Called 9 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    9              0.000133   if exists('#User#'.a:name)
                                exe 'doautocmd User '.a:name
    9              0.000008   endif

FUNCTION  <SNR>30_variables()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 315
Called 2 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    2              0.000066   let info = getbufinfo({'bufnr':a:bufnr, 'variables': 1})
    2              0.000029   let variables = copy(info[0]['variables'])
    4              0.000009   for key in keys(variables)
    2              0.000015     if key !~# '\v^coc'
    2              0.000004       unlet variables[key]
    2              0.000001     endif
    4              0.000003   endfor
    2              0.000002   return variables

FUNCTION  GetJsxIndent()
    Defined: ~/.vim/plugged/vim-jsx-pretty/after/indent/javascript.vim line 24
Called 1 time
Total time:   0.001544
 Self time:   0.000020

count  total (s)   self (s)
    1   0.001543   0.000019   return jsx_pretty#indent#get(function('GetJavascriptIndent'))

FUNCTION  NERDComment()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1232
Called 1 time
Total time:   0.028530
 Self time:   0.000367

count  total (s)   self (s)
    1              0.000007     if exists('*NERDCommenter_before')
                                    exe 'call NERDCommenter_before()'
    1              0.000002     endif
                            
    1              0.000014     let isVisual = a:mode =~# '[vsx]'
                            
    1              0.000005     if !exists('g:did_load_ftplugin') || g:did_load_ftplugin !=# 1
                                    call s:NerdEcho('filetype plugins should be enabled. See :help NERDComInstallation and :help :filetype-plugin-on', 0)
    1              0.000001     endif
                            
    1              0.000001     if isVisual
    1              0.000004         let firstLine = line("'<")
    1              0.000002         let lastLine = line("'>")
    1              0.000002         let firstCol = col("'<")
    1              0.000006         let lastCol = col("'>") - (&selection ==# 'exclusive' ? 1 : 0)
                                else
                                    let firstLine = a:firstline
                                    let lastLine = a:lastline
    1              0.000001     endif
                                "
                                " Save options we need to change so we can recover them later
    1   0.000064   0.000024     let state = s:SetupStateBeforeLineComment(firstLine, lastLine)
                            
    1              0.000003     let countWasGiven = (!isVisual && firstLine !=# lastLine)
                            
    1              0.000004     let forceNested = (a:type ==? 'Nested' || g:NERDDefaultNesting)
                            
    1              0.000002     if a:type ==? 'Comment' || a:type ==? 'Nested'
                                    if isVisual && visualmode() ==# "\<C-V>"
                                        call s:CommentBlock(firstLine, lastLine, firstCol, lastCol, forceNested)
                                    elseif isVisual && visualmode() ==# 'v' && (g:NERDCommentWholeLinesInVMode==#0 || (g:NERDCommentWholeLinesInVMode==#2 && s:HasMultipartDelims()))
                                        call s:CommentRegion(firstLine, firstCol, lastLine, lastCol, forceNested)
                                    else
                                        call s:CommentLines(forceNested, g:NERDDefaultAlign, firstLine, lastLine)
                                    endif
                            
    1              0.000002     elseif a:type ==? 'AlignLeft' || a:type ==? 'AlignBoth'
                                    let align = 'none'
                                    if a:type ==? 'AlignLeft'
                                        let align = 'left'
                                    elseif a:type ==? 'AlignBoth'
                                        let align = 'both'
                                    endif
                                    call s:CommentLines(forceNested, align, firstLine, lastLine)
                            
    1              0.000001     elseif a:type ==? 'Invert'
                                    call s:InvertComment(firstLine, lastLine)
                            
    1              0.000001     elseif a:type ==? 'Sexy'
                                    try
                                        call s:CommentLinesSexy(firstLine, lastLine)
                                    catch /NERDCommenter.Delimiters/
                                        call s:CommentLines(forceNested, g:NERDDefaultAlign, firstLine, lastLine)
                                    catch /NERDCommenter.Nesting/
                                        call s:NerdEcho('Sexy comment aborted. Nested sexy cannot be nested', 0)
                                    endtry
                            
    1              0.000001     elseif a:type ==? 'Toggle'
    1              0.000002         if g:NERDToggleCheckAllLines ==# 0
    1              0.000004           let theLine = getline(firstLine)
    1   0.001238   0.000109           if s:IsInSexyComment(firstLine) || s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
                                          call s:UncommentLines(firstLine, lastLine)
    1              0.000001           else
    1   0.026787   0.000020               call s:CommentLinesToggle(forceNested, firstLine, lastLine)
    1              0.000000           endif
                                    else
                                      let l:commentAllLines = 0
                                      for i in range(firstLine, lastLine)
                                        let theLine = getline(i)
                                        " if have one line no comment(not include blank/whitespace-only lines), then comment all lines
                                        if theLine =~# '[^ \t]\+' && !s:IsInSexyComment(firstLine) && !s:IsCommentedFromStartOfLine(s:Left(), theLine) && !s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)
                                          let l:commentAllLines = 1
                                          break
                                        else
                                      endif
                                      endfor
                                      if l:commentAllLines ==# 1
                                        call s:CommentLinesToggle(forceNested, firstLine, lastLine)
                                      else
                                        call s:UncommentLines(firstLine, lastLine)
                                      endif
    1              0.000000         endif
                            
                                elseif a:type ==? 'Minimal'
                                    try
                                        call s:CommentLinesMinimal(firstLine, lastLine)
                                    catch /NERDCommenter.Delimiters/
                                        call s:NerdEcho('Minimal comments can only be used for filetypes that have multipart delimiters.', 0)
                                    catch /NERDCommenter.Settings/
                                        call s:NerdEcho('Place holders are required but disabled.', 0)
                                    endtry
                            
                                elseif a:type ==? 'ToEOL'
                                    call s:SaveScreenState()
                                    call s:CommentBlock(firstLine, firstLine, col('.'), col('$')-1, 1)
                                    call s:RestoreScreenState()
                            
                                elseif a:type ==? 'Append'
                                    call s:AppendCommentToLine()
                            
                                elseif a:type ==? 'Insert'
                                    call s:PlaceDelimitersAndInsBetween()
                            
                                elseif a:type ==? 'Uncomment'
                                    call s:UncommentLines(firstLine, lastLine)
                            
                                elseif a:type ==? 'Yank'
                                    if isVisual
                                        normal! gvy
                                    elseif countWasGiven
                                        execute firstLine .','. lastLine .'yank'
                                    else
                                        normal! yy
                                    endif
                                    execute firstLine .','. lastLine .'call NERDComment("'. a:mode .'", "Comment")'
    1              0.000000     endif
                            
    1   0.000033   0.000011     call s:RecoverStateAfterLineComment(state)
                            
    1              0.000001     if isVisual
    1              0.000002         let nlines = lastLine - firstLine
    1   0.000217   0.000011         silent! call repeat#set('V' . nlines . 'jo' . "\<Plug>NERDCommenter". a:type)
                                else
                                    silent! call repeat#set("\<Plug>NERDCommenter". a:type)
    1              0.000000     endif
                            
    1              0.000003     if exists('*NERDCommenter_after')
                                    exe 'call NERDCommenter_after()'
    1              0.000000     endif
                            

FUNCTION  ale#handlers#eslint#HandleJSON()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 254
Called 6 times
Total time:   0.010504
 Self time:   0.000065

count  total (s)   self (s)
    6   0.010501   0.000063     return s:HandleESLintOutput(a:buffer, a:lines, 'json')

FUNCTION  <SNR>131_LookingAt()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 161
Called 6 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    6              0.000016   return getline('.')[col('.')-1]

FUNCTION  ale#events#QuitRecently()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 19
Called 6 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000029     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    6              0.000018     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>28_SyncAutocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 166
Called 9 times
Total time:   0.077529
 Self time:   0.000317

count  total (s)   self (s)
    9              0.000041   if !get(g:,'coc_workspace_initialized', 0)
                                return
    9              0.000006   endif
    9              0.000022   if get(g:, 'coc_service_initialized', 0)
    9   0.077392   0.000180     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    9              0.000006   endif

FUNCTION  <SNR>169_blue()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 206
Called 1 time
Total time:   0.000245
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000244   0.000016    return s:ansi(a:str, get(a:, 1, ''), 'blue')

FUNCTION  <SNR>52_Esc()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2166
Called 63 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
   63              0.000090     let charsToEsc = '*/\."&$+'
   63              0.000174     return escape(a:str, charsToEsc)

FUNCTION  <SNR>169_get_color()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 174
Called 2 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    2              0.000013   let gui = has('termguicolors') && &termguicolors
    2              0.000003   let fam = gui ? 'gui' : 'cterm'
    2              0.000003   let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
    3              0.000006   for group in a:000
    2              0.000079     let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
    2              0.000017     if code =~? pat
    1              0.000002       return code
    1              0.000001     endif
    2              0.000003   endfor
    1              0.000001   return ''

FUNCTION  ale#fixers#eslint#Fix()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/eslint.vim line 4
Called 3 times
Total time:   0.013562
 Self time:   0.000191

count  total (s)   self (s)
    3   0.005152   0.000070     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
    3   0.000184   0.000055     let l:command = ale#node#Executable(a:buffer, l:executable)   . ' --version'
                            
    3   0.008220   0.000060     return ale#semver#RunWithVersionCheck(   a:buffer,   l:executable,   l:command,   function('ale#fixers#eslint#ApplyFixForVersion'),)

FUNCTION  <SNR>52_AddLeftDelim()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1902
Called 20 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
   20              0.000211     return substitute(a:theLine, '^\([ \t]*\)', '\1' . a:delim, '')

FUNCTION  ale#util#JoinNeovimOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 54
Called 46 times
Total time:   0.023967
 Self time:   0.019806

count  total (s)   self (s)
   46              0.000090     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
   46              0.000020     endif
                            
   46              0.000439     let l:lines = a:data[:-2]
                            
   46              0.000098     if len(a:data) > 1
   16              0.000115         let l:lines[0] = a:last_line . l:lines[0]
   16              0.000025         let l:new_last_line = a:data[-1]
   30              0.000016     else
   30              0.000127         let l:new_last_line = a:last_line . get(a:data, 0, '')
   46              0.000019     endif
                            
 2012              0.001486     for l:line in l:lines
 1966   0.019708   0.015546         call a:callback(a:job, l:line)
 2012              0.000971     endfor
                            
   46              0.000051     return l:new_last_line

FUNCTION  <SNR>169_action_for()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 241
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002   let default = a:0 ? a:1 : ''
    1              0.000005   let Cmd = get(get(g:, 'fzf_action', s:default_action), a:key, default)
    1              0.000003   return type(Cmd) == s:TYPE.string ? Cmd : default

FUNCTION  <SNR>49_fzf_tempname()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 114
Called 2 times
Total time:   0.000027
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000026   0.000016   return s:fzf_call('tempname')

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 72
Called 12 times
Total time:   0.000418
 Self time:   0.000324

count  total (s)   self (s)
   12              0.000019     if s:has_nvim_highlight
   12   0.000280   0.000186         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
   12              0.000006     endif

FUNCTION  <SNR>159_WinFindBuf()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim line 74
Called 6 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    6              0.000036     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 228
Called 6 times
Total time:   0.001172
 Self time:   0.000158

count  total (s)   self (s)
    6   0.000424   0.000098     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    6   0.000741   0.000053     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>169_fill_quickfix()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 276
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002   if len(a:list) > 1
                                call setqflist(a:list)
                                copen
                                wincmd p
                                if a:0
                                  execute a:1
                                endif
    1              0.000000   endif

FUNCTION  coc#util#clearmatches()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 743
Called 6 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
    6              0.000036   let winid = get(a:, 1, 0)
    6              0.000015   if winid != 0 && win_getid() != winid
                                return
    6              0.000004   endif
    6              0.000012   for id in a:ids
                                try
                                  call matchdelete(id)
                                catch /.*/
                                  " matches have been cleared in other ways,
                                endtry
    6              0.000010   endfor
    6              0.000017   let exists = get(w:, 'coc_matchids', [])
    6              0.000011   if !empty(exists)
                                call filter(w:coc_matchids, 'index(a:ids, v:val) == -1')
    6              0.000003   endif

FUNCTION  <SNR>49_escape()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 189
Called 6 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    6              0.000035   let path = fnameescape(a:path)
    6              0.000017   return s:is_win ? escape(path, '$') : path

FUNCTION  ale#highlight#nvim_buf_add_highlight()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 36
Called 5 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                                " Ignore all errors for adding highlights.
    5              0.000004     try
    5              0.000118         call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
    5              0.000003     endtry

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim line 144
Called 15 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   15              0.000044     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
   15              0.000008     endif

FUNCTION  ale#util#FuzzyJSONDecode()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 391
Called 3 times
Total time:   0.000399
 Self time:   0.000399

count  total (s)   self (s)
    3              0.000007     if empty(a:data)
                                    return a:default
    3              0.000001     endif
                            
    3              0.000034     let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
                            
    3              0.000002     try
    3              0.000306         let l:result = json_decode(l:str)
                            
                                    " Vim 8 only uses the value v:none for decoding blank strings.
    3              0.000014         if !has('nvim') && l:result is v:none
                                        return a:default
    3              0.000002         endif
                            
    3              0.000004         return l:result
                                catch /E474/
                                    return a:default
    3              0.000003     endtry

FUNCTION  fzf#vim#grep()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 716
Called 2 times
Total time:   0.066682
 Self time:   0.000307

count  total (s)   self (s)
    2              0.000003   let words = []
    4              0.000083   for word in split(a:grep_command)
    4              0.000019     if word !~# '^[a-z]'
    2              0.000002       break
    2              0.000001     endif
    2              0.000006     call add(words, word)
    4              0.000012   endfor
    2              0.000006   let words   = empty(words) ? ['grep'] : words
    2              0.000007   let name    = join(words, '-')
    2              0.000020   let capname = join(map(words, 'toupper(v:val[0]).v:val[1:]'), '')
    2              0.000016   let opts = { 'column':  a:has_column, 'options': ['--ansi', '--prompt', capname.'> ',             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',             '--color', 'hl:4,hl+:12']}
    2              0.000004   function! opts.sink(lines)
                                return s:ag_handler(a:lines, self.column)
                              endfunction
    2              0.000010   let opts['sink*'] = remove(opts, 'sink')
    2              0.000002   try
    2              0.000020     let prev_default_command = $FZF_DEFAULT_COMMAND
    2              0.000013     let $FZF_DEFAULT_COMMAND = a:grep_command
    2   0.066418   0.000043     return s:fzf(name, opts, a:000)
    2              0.000001   finally
    2              0.000010     let $FZF_DEFAULT_COMMAND = prev_default_command
    2              0.000001   endtry

FUNCTION  <SNR>146_FilterResult()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 208
Called 3 times
Total time:   0.000088
 Self time:   0.000052

count  total (s)   self (s)
    3   0.000056   0.000020     if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                    if a:obj.text =~# '^File ignored'
                                        return 0
                                    endif
    3              0.000001     endif
                            
    3              0.000012     if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    return 0
    3              0.000001     endif
                            
    3              0.000002     return 1

FUNCTION  fzf#vim#with_preview()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 78
Called 2 times
Total time:   0.000320
 Self time:   0.000159

count  total (s)   self (s)
                              " Default options
    2              0.000005   let options = {}
    2              0.000002   let window = ''
                            
    2              0.000006   let args = copy(a:000)
                            
                              " Options to wrap
    2              0.000008   if len(args) && type(args[0]) == s:TYPE.dict
                                let options = copy(args[0])
                                call remove(args, 0)
    2              0.000002   endif
                            
                              " Placeholder expression (TODO/TBD: undocumented)
    2              0.000008   let placeholder = get(options, 'placeholder', '{}')
                            
                              " Preview window
    2              0.000006   if len(args) && type(args[0]) == s:TYPE.string
                                if args[0] !~# '^\(up\|down\|left\|right\)'
                                  throw 'invalid preview window: '.args[0]
                                endif
                                let window = args[0]
                                call remove(args, 0)
    2              0.000001   endif
                            
    2              0.000003   let preview = []
    2              0.000006   if len(window)
                                let preview += ['--preview-window', window]
    2              0.000001   endif
    2   0.000115   0.000031   let preview += ['--preview', (s:is_win ? s:bin.preview : fzf#shellescape(s:bin.preview)).' '.placeholder]
                            
    2              0.000003   if len(args)
                                call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
    2              0.000001   endif
    2   0.000095   0.000018   call s:merge_opts(options, preview)
    2              0.000002   return options

FUNCTION  ale#fixers#prettier#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/prettier.vim line 9
Called 6 times
Total time:   0.012454
 Self time:   0.000129

count  total (s)   self (s)
    6   0.012451   0.000126     return ale#node#FindExecutable(a:buffer, 'javascript_prettier', [   'node_modules/.bin/prettier_d',   'node_modules/prettier-cli/index.js',   'node_modules/.bin/prettier',])

FUNCTION  jsx_pretty#indent#get()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 236
Called 1 time
Total time:   0.001524
 Self time:   0.000266

count  total (s)   self (s)
    1   0.000027   0.000015   let line = s:trim(getline(v:lnum))
    1   0.000038   0.000010   let start_syntax = s:start_syntax(v:lnum)
                            
    1   0.000015   0.000010   if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
    1              0.000001   endif
                            
    1   0.000012   0.000008   if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
    1              0.000000   endif
                            
    1   0.000033   0.000029   if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
    1              0.000000   endif
                            
    1   0.000621   0.000011   let syntax_context = s:syntax_context(v:lnum)
                            
    1              0.000002   if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' && s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
    1              0.000015   elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
    1              0.000002   elseif syntax_context == 'jsxElement'
                                if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                return s:jsx_indent_element(v:lnum)
    1              0.000001   elseif syntax_context == 'jsxExpressionBlock'
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
                                elseif line =~ '^:'
                                  return indent(prev_lnum)
                                else
                                  return a:js_indent()
                                endif
    1              0.000000   endif
                            
    1   0.000612   0.000017   return a:js_indent()

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 90
Called 27 times
Total time:   0.000782
 Self time:   0.000782

count  total (s)   self (s)
   27              0.000354   let pos = getcurpos()
   27              0.000200   let content = pos[2] == 1 ? '' : getline('.')[0: pos[2] - 2]
   27              0.000151   return [pos[1] - 1, strchars(content)]

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 136
Called 12 times
Total time:   0.001972
 Self time:   0.000993

count  total (s)   self (s)
   12              0.000120     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   12   0.000585   0.000167     call ale#highlight#RemoveHighlights()
                            
   17              0.000023     for l:item in l:item_list
    5              0.000008         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
    5              0.000007         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
    5              0.000012         elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
    5              0.000002         else
    5              0.000006             let l:group = 'ALEError'
    5              0.000002         endif
                            
    5              0.000034         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
    5   0.000620   0.000059         call s:highlight_range(l:item.bufnr, l:range, l:group)
   17              0.000031     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   12              0.000014     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
   12              0.000006     endif

FUNCTION  <SNR>105_synGroupID()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 47
Called 72 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
   72              0.000215 	return a:prefix.a:group.'_lv'.a:lv

FUNCTION  <SNR>158_PriorityCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 153
Called 11 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   11              0.000012     if s:supports_sign_groups
   11              0.000023         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  lightline#update()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 13
Called 14 times
Total time:   0.035200
 Self time:   0.001305

count  total (s)   self (s)
   14              0.000060   if &buftype ==# 'popup' | return | endif
   14              0.000017   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
   14              0.000006   endif
   14              0.000031   if !s:lightline.enable.statusline
                                return
   14              0.000005   endif
   14              0.000035   let w = winnr()
   14   0.034191   0.000296   let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   62              0.000098   for n in range(1, winnr('$'))
   48              0.000561     call setwinvar(n, '&statusline', s[n!=w])
   62              0.000042   endfor

FUNCTION  <SNR>52_SetUpForNewFiletype()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 526
Called 8 times
Total time:   0.001001
 Self time:   0.000667

count  total (s)   self (s)
    8              0.000023     let filetype = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    8              0.000049     if filetype =~# '\.' && !has_key(s:delimiterMap, filetype)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let filetype = i
                                            break
                                        endif
                                    endfor
    8              0.000004     endif
                            
    8              0.000015     let b:NERDSexyComMarker = ''
                            
    8              0.000028     if has_key(s:delimiterMap, filetype)
    2              0.000013         let b:NERDCommenterDelims = s:delimiterMap[filetype]
   10              0.000012         for i in ['left', 'leftAlt', 'right', 'rightAlt']
    8              0.000015             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
    8              0.000003             endif
   10              0.000005         endfor
    6              0.000007         for i in ['nested', 'nestedAlt']
    4              0.000007             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
    4              0.000002             endif
    6              0.000004         endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
    2              0.000007         let b:NERDCommenterFirstInit = getbufvar(1,'NERDCommenterFirstInit')
    2              0.000009         if exists('g:NERDAltDelims_'.filetype) && eval('g:NERDAltDelims_'.filetype) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
    2              0.000001         endif
    6              0.000004     else
    6   0.000508   0.000174         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    8              0.000007     endif
                            

FUNCTION  ale#job#Start()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim line 215
Called 15 times
Total time:   0.026936
 Self time:   0.026850

count  total (s)   self (s)
   15   0.000293   0.000207     call ale#job#ValidateArguments(a:command, a:options)
                            
   15              0.000069     let l:job_info = copy(a:options)
   15              0.000020     let l:job_options = {}
                            
   15              0.000036     if has('nvim')
   15              0.000032         if has_key(a:options, 'out_cb')
   15              0.000070             let l:job_options.on_stdout = function('s:NeoVimCallback')
   15              0.000025             let l:job_info.out_cb_line = ''
   15              0.000008         endif
                            
   15              0.000027         if has_key(a:options, 'err_cb')
    9              0.000031             let l:job_options.on_stderr = function('s:NeoVimCallback')
    9              0.000012             let l:job_info.err_cb_line = ''
   15              0.000007         endif
                            
   15              0.000025         if has_key(a:options, 'exit_cb')
   15              0.000049             let l:job_options.on_exit = function('s:NeoVimCallback')
   15              0.000006         endif
                            
   15              0.024936         let l:job_info.job = jobstart(a:command, l:job_options)
   15              0.000096         let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
   15              0.000009     endif
                            
   15              0.000021     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   15              0.000091         let s:job_map[l:job_id] = l:job_info
   15              0.000009     endif
                            
   15              0.000038     return l:job_id

FUNCTION  <SNR>52_CreateDelimMapFromCms()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 567
Called 6 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
    6              0.000019     if &filetype ==# '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
    6              0.000003     endif
    6              0.000259     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  <SNR>52_Nested()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2893
Called 20 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   20              0.000045     return b:NERDCommenterDelims['nested']

FUNCTION  ale#util#HasBuflineApi()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 480
Called 5 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    5              0.000027     return exists('*deletebufline') && exists('*setbufline')

FUNCTION  ale#handlers#eslint#GetCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 40
Called 9 times
Total time:   0.016220
 Self time:   0.000735

count  total (s)   self (s)
    9   0.011219   0.000114     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
    9   0.000210   0.000093     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
                                " ESLint 6 loads plugins/configs/parsers from the project root
                                " By default, the project root is simply the CWD of the running process.
                                " https://github.com/eslint/rfcs/blob/master/designs/2018-simplified-package-loading/README.md
                                " https://github.com/dense-analysis/ale/issues/2787
                                " Identify project root from presence of node_modules dir.
                                " Note: If node_modules not present yet, can't load local deps anyway.
    9   0.003805   0.000157     let l:modules_dir = ale#path#FindNearestDirectory(a:buffer, 'node_modules')
    9              0.000053     let l:project_dir = !empty(l:modules_dir) ? fnamemodify(l:modules_dir, ':h:h') : ''
    9   0.000477   0.000126     let l:cd_command = !empty(l:project_dir) ? ale#path#CdString(l:project_dir) : ''
                            
    9   0.000409   0.000147     return l:cd_command   . ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp_linter.vim line 347
Called 18 times
Total time:   0.023555
 Self time:   0.000812

count  total (s)   self (s)
   18              0.000028     let l:command = ''
   18              0.000019     let l:address = ''
   18   0.014700   0.000263     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
   18              0.000056     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
    9              0.000007         return 0
    9              0.000004     endif
                            
    9              0.000048     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    9              0.000012     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
    9              0.000004     endif
                            
    9   0.007111   0.000135     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    9   0.001437   0.000108     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  rainbow#activate()
    Defined: ~/.vim/plugged/vim-rainbow/plugin/rainbow.vim line 112
Called 2 times
Total time:   0.000672
 Self time:   0.000672

count  total (s)   self (s)
    2              0.000007     if !exists('b:loaded')
                                    cal rainbow#load()
    2              0.000001     endif
    2              0.000022     exe 'hi default op_lv0 ctermfg='.s:ctermfgs[-1].' guifg='.s:guifgs[-1]
   34              0.000032     for id in range(1 , s:max)
   32              0.000069         let ctermfg = s:ctermfgs[(s:max - id) % len(s:ctermfgs)]
   32              0.000127         let guifg = s:guifgs[(s:max - id) % len(s:guifgs)]
   32              0.000174         exe 'hi default lv'.id.'c ctermfg='.ctermfg.' guifg='.guifg
   32              0.000172         exe 'hi default op_lv'.id.' ctermfg='.ctermfg.' guifg='.guifg
   34              0.000018     endfor
    2              0.000009     exe 'syn sync fromstart'
    2              0.000012     let b:active = 'active'

FUNCTION  ale#fix#Fix()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 345
Called 3 times
Total time:   0.028929
 Self time:   0.000626

count  total (s)   self (s)
    3              0.000009     if a:fixing_flag isnot# '' && a:fixing_flag isnot# 'save_file'
                                    throw "fixing_flag must be either '' or 'save_file'"
    3              0.000002     endif
                            
    3              0.000002     try
    3   0.001024   0.000070         let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
                                catch /E700\|BADNAME/
                                    let l:function_name = join(split(split(v:exception, ':')[3]))
                                    let l:echo_message = printf(   'There is no fixer named `%s`. Check :ALEFixSuggest',   l:function_name,)
                                    execute 'echom l:echo_message'
                            
                                    return 0
    3              0.000002     endtry
                            
    3              0.000006     if empty(l:callback_list)
                                    if a:fixing_flag is# ''
                                        execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
                                    endif
                            
                                    return 0
    3              0.000001     endif
                            
    3   0.000108   0.000032     call ale#command#StopJobs(a:buffer, 'fixer')
                                " Clean up any files we might have left behind from a previous run.
    3   0.000110   0.000032     call ale#command#RemoveManagedFiles(a:buffer)
    3   0.000592   0.000045     call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
                            
    3   0.000230   0.000214     silent doautocmd <nomodeline> User ALEFixPre
                            
    3   0.026762   0.000128     call s:RunFixer({   'buffer': a:buffer,   'input': g:ale_fix_buffer_data[a:buffer].lines_before,   'callback_index': 0,   'callback_list': l:callback_list,})
                            
    3              0.000008     return 1

FUNCTION  <SNR>75_NERDTreeGetIndicator()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 183
Called 34 times
Total time:   0.000546
 Self time:   0.000546

count  total (s)   self (s)
   34              0.000096     if exists('g:NERDTreeIndicatorMapCustom')
   34              0.000104         let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
   34              0.000046         if l:indicator !=# ''
    2              0.000002             return l:indicator
   32              0.000015         endif
   32              0.000012     endif
   32              0.000080     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
   32              0.000059     if l:indicator !=# ''
                                    return l:indicator
   32              0.000015     endif
   32              0.000018     return ''

FUNCTION  coc#rpc#request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 92
Called 9 times
Total time:   0.077212
 Self time:   0.000248

count  total (s)   self (s)
    9   0.000149   0.000077   if !coc#rpc#ready()
                                return ''
    9              0.000004   endif
    9   0.077027   0.000135   return s:client['request'](a:method, a:args)

FUNCTION  ale#node#Executable()
    Defined: ~/.vim/plugged/ale/autoload/ale/node.vim line 34
Called 15 times
Total time:   0.000513
 Self time:   0.000288

count  total (s)   self (s)
   15              0.000067     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
   15              0.000009     endif
                            
   15   0.000336   0.000111     return ale#Escape(a:executable)

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp_linter.vim line 412
Called 18 times
Total time:   0.023889
 Self time:   0.000333

count  total (s)   self (s)
   18   0.023879   0.000324     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  <SNR>52_SetupStateBeforeLineComment()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1585
Called 1 time
Total time:   0.000040
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000006     let state = {'foldmethod' : &foldmethod,'ignorecase' : &ignorecase}
                            
                                " Vim's foldmethods are evaluated every time we use 'setline', which can
                                " make commenting wide ranges of lines VERY slow. We'll change it to
                                " manual, do the commenting stuff and recover it later. To avoid slowing
                                " down commenting few lines, we avoid doing this for ranges smaller than
                                " 10 lines
    1              0.000004     if a:bottomLine - a:topLine >= 10 && &foldmethod !=# 'manual'
    1   0.000013   0.000011         set foldmethod=manual
    1              0.000001     endif
                            
                                " we want case sensitivity when commenting
    1   0.000008   0.000004     set noignorecase
                            
    1              0.000002     return state

FUNCTION  <SNR>144_RunIfExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 611
Called 63 times
Total time:   0.057057
 Self time:   0.003754

count  total (s)   self (s)
   63   0.001074   0.000769     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
   63              0.000036     endif
                            
   63   0.006637   0.000728     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    9              0.000021         let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
    9              0.000053         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
    9              0.000019         if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
    9              0.000005         endif
                            
    9   0.016528   0.000094         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    9              0.000083         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
    9   0.030862   0.000207         return s:RunJob(l:command, l:options)
   54              0.000024     endif
                            
   54              0.000032     return 0

FUNCTION  <SNR>134_GetAliasedFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 403
Called 12 times
Total time:   0.000660
 Self time:   0.000660

count  total (s)   self (s)
   12              0.000074     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
   12              0.000062     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
   12              0.000012     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   48              0.000118     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   36              0.000112         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
   36              0.000022         endif
   48              0.000052     endfor
                            
   12              0.000016     return a:original_filetype

FUNCTION  <SNR>145_GatherOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 207
Called 1966 times
Total time:   0.004162
 Self time:   0.004162

count  total (s)   self (s)
 1966              0.003527     call add(a:line_list, a:line)

FUNCTION  <SNR>75_NERDTreeGetFileGitStatusKey()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 197
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000005     if a:us ==# '?' && a:them ==# '?'
    1              0.000001         return 'Untracked'
    1              0.000002     elseif a:us ==# ' ' && a:them ==# 'M'
    1              0.000001         return 'Modified'
                                elseif a:us =~# '[MAC]'
                                    return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
                                    return 'Deleted'
                                elseif a:us ==# '!'
                                    return 'Ignored'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  <SNR>160_highlight_range()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 122
Called 5 times
Total time:   0.000562
 Self time:   0.000140

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
    5   0.000554   0.000132     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  <SNR>49_present()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 438
Called 7 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
   11              0.000023   for key in a:000
    9              0.000037     if !empty(get(a:dict, key, ''))
    5              0.000005       return 1
    4              0.000002     endif
    6              0.000006   endfor
    2              0.000002   return 0

FUNCTION  <SNR>52_FindDelimiterIndex()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2178
Called 82 times
Total time:   0.003799
 Self time:   0.003339

count  total (s)   self (s)
                            
                                "make sure the delimiter isn't empty otherwise we go into an infinite loop.
   82              0.000133     if a:delimiter ==# ''
                                    return -1
   82              0.000038     endif
                            
                            
   82              0.000133     let l:delimiter = a:delimiter
   82              0.000192     let lenDel = strlen(l:delimiter)
                            
                                "get the index of the first occurrence of the delimiter
   82              0.000220     let delIndx = stridx(a:line, l:delimiter)
                            
                                "keep looping thru the line till we either find a real comment delimiter
                                "or run off the EOL
   84              0.000127     while delIndx !=# -1
                            
                                    "if we are not off the EOL get the str before the possible delimiter
                                    "in question and check if it really is a delimiter. If it is, return
                                    "its position
    2              0.000002         if delIndx !=# -1
    2   0.000482   0.000022             if s:IsDelimValid(l:delimiter, delIndx, a:line)
                                            return delIndx
    2              0.000001             endif
    2              0.000001         endif
                            
                                    "we have not yet found a real comment delimiter so move past the
                                    "current one we are looking at
    2              0.000008         let restOfLine = strpart(a:line, delIndx + lenDel)
    2              0.000006         let distToNextDelim = stridx(restOfLine , l:delimiter)
                            
                                    "if distToNextDelim is -1 then there is no more potential delimiters
                                    "on the line so set delIndx to -1. Otherwise, move along the line by
                                    "distToNextDelim
    2              0.000002         if distToNextDelim ==# -1
    2              0.000003             let delIndx = -1
                                    else
                                        let delIndx = delIndx + lenDel + distToNextDelim
    2              0.000001         endif
   84              0.000258     endwhile
                            
                                "there is no comment delimiter on this line
   82              0.000060     return -1

FUNCTION  13()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 288
Called 24 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
   24              0.000032     if self.cachedDisplayString ==# ''
                                    call self.cacheDisplayString()
   24              0.000009     endif
                            
   24              0.000018     return self.cachedDisplayString

FUNCTION  15()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 304
Called 3 times
Total time:   0.000093
 Self time:   0.000072

count  total (s)   self (s)
    3   0.000048   0.000027     if nerdtree#runningWindows()
                                    if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', 'g')
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
    3              0.000002     else
    3              0.000009         let self.drive = ''
    3              0.000002     endif
                            

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim line 58
Called 6 times
Total time:   0.000338
 Self time:   0.000074

count  total (s)   self (s)
    6   0.000320   0.000056     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    6              0.000010     let l:obj.output = a:output

FUNCTION  <SNR>52_RightMostIndx()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 3020
Called 1 time
Total time:   0.001050
 Self time:   0.000821

count  total (s)   self (s)
    1              0.000001     let rightMostIndx = -1
                            
                                " go thru the block line by line updating rightMostIndx
    1              0.000002     let currentLine = a:topline
   21              0.000024     while currentLine <= a:bottomline
                            
                                    " get the next line and see if it is commentable, otherwise it doesn't
                                    " count
   20              0.000041         let theLine = getline(currentLine)
   20              0.000100         if a:countEmptyLines || theLine !~# '^[ \t]*$'
                            
   20              0.000123             if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))
                            
                                            " update rightMostIndx if need be
   20   0.000531   0.000302                 let theLine = s:ConvertLeadingTabsToSpaces(theLine)
   20              0.000040                 let lineLen = strlen(theLine)
   20              0.000022                 if lineLen > rightMostIndx
    2              0.000002                     let rightMostIndx = lineLen
   20              0.000009                 endif
   20              0.000008             endif
   20              0.000009         endif
                            
                                    " move on to the next line
   20              0.000026         let currentLine = currentLine + 1
   21              0.000013     endwhile
                            
    1              0.000001     return rightMostIndx

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 32
Called 47 times
Total time:   0.005822
 Self time:   0.004429

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   47              0.000258     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   47              0.000023     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   47              0.000165     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   47              0.000019     endif
                            
   47              0.000194     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   47              0.000069     if l:filetype is# ''
    2              0.000002         return 1
   45              0.000019     endif
                            
                                " Do nothing for diff buffers.
   45              0.000127     if getbufvar(a:buffer, '&diff')
                                    return 1
   45              0.000017     endif
                            
                                " Do nothing for blacklisted files.
   45              0.000233     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
    2              0.000002         return 1
   43              0.000017     endif
                            
                                " Do nothing if running from command mode.
   43              0.000150     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
   43              0.000016     endif
                            
   43              0.000216     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   43              0.000059     if l:filename is# '.'
                                    return 1
   43              0.000018     endif
                            
                                " Don't start linting and so on when an operator is pending.
   43   0.000706   0.000483     if ale#util#Mode(1) is# 'no'
                                    return 1
   43              0.000019     endif
                            
                                " Do nothing if running in the sandbox.
   43   0.001060   0.000373     if ale#util#InSandbox()
                                    return 1
   43              0.000017     endif
                            
                                " Do nothing if the file is too large.
   43   0.001030   0.000548     if ale#FileTooLarge(a:buffer)
                                    return 1
   43              0.000017     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   43              0.000364     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
   43              0.000016     endif
                            
   43              0.000025     return 0

FUNCTION  xolox#session#auto_save()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim line 443
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000002   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
    1              0.000001   endif
    1              0.000002   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
    1              0.000001     return
                              endif
                              " Get the name of the session for automatic saving.
                              let name = xolox#misc#option#get('session_autosave_to')
                              if empty(name)
                                " Get the name of the active session (if any).
                                let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
                                if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
                              endif
                              " Prompt the user to save the active/first/default session?
                              if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
                              endif

FUNCTION  27()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 494
Called 64 times
Total time:   0.008766
 Self time:   0.003228

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   64   0.000323   0.000248     if a:nerdtree.ui.isIgnoreFilterEnabled()
  224              0.000206         for i in g:NERDTreeIgnore
  176   0.005922   0.000817             if self._ignorePatternMatches(i)
   16              0.000011                 return 1
  160              0.000060             endif
  208              0.000118         endfor
                            
   48   0.000559   0.000319         for Callback in g:NERDTree.PathFilters()
                                        let Callback = type(Callback) ==# type(function('tr')) ? Callback : function(Callback)
                                        if Callback({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
   48              0.000052         endfor
   48              0.000019     endif
                            
                                "dont show hidden files unless instructed to
   48   0.000286   0.000229     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
   48              0.000016     endif
                            
   48   0.000340   0.000279     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
   48              0.000016     endif
                            
   48              0.000024     return 0

FUNCTION  28()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 525
Called 176 times
Total time:   0.005105
 Self time:   0.003902

count  total (s)   self (s)
  176              0.000201     let pat = a:pattern
  176              0.000476     if strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
  176              0.000444     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
  176              0.000074     endif
                            
  176   0.002567   0.001364     return self.getLastPathComponent(0) =~# pat

FUNCTION  <SNR>96_flatten_twice()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 347
Called 56 times
Total time:   0.001383
 Self time:   0.001383

count  total (s)   self (s)
   56              0.000104   let ys = []
  168              0.000192   for xs in a:xss
  294              0.000234     for x in xs
  182              0.000218       let ys += x
  294              0.000156     endfor
  168              0.000115   endfor
   56              0.000053   return ys

FUNCTION  115()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim line 112
Called 30 times
Total time:   0.009492
 Self time:   0.000409

count  total (s)   self (s)
   30   0.009380   0.000296     if a:path.equals(self.path)
                                    return self
   30              0.000014     endif
   30              0.000029     return {}

FUNCTION  117()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim line 157
Called 98 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
   98              0.000100     return self._nerdtree

FUNCTION  <SNR>146_CheckForBadConfig()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 72
Called 6 times
Total time:   0.009060
 Self time:   0.009060

count  total (s)   self (s)
    6              0.000032     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
   12              0.000043     for l:line in a:lines[:10]
    6              0.008825         let l:match = matchlist(l:line, l:config_error_pattern)
                            
    6              0.000019         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
    6              0.000008         endif
   12              0.000015     endfor
                            
    6              0.000005     return 0

FUNCTION  <SNR>52_GetSexyComMarker()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2310
Called 21 times
Total time:   0.003153
 Self time:   0.001169

count  total (s)   self (s)
   21              0.000063     let sexyComMarker = b:NERDSexyComMarker
                            
                                "if there is no hardcoded marker then we find one
   21              0.000028     if sexyComMarker ==# ''
                            
                                    "if the filetype has c style comments then use standard c sexy
                                    "comments
   21   0.002117   0.000231         if s:HasCStyleComments()
   21              0.000046             let sexyComMarker = '*'
                                    else
                                        "find a comment marker by getting the longest available left delimiter
                                        "(that has a corresponding right delimiter) and taking the last char
                                        let lenLeft = strlen(s:Left())
                                        let lenLeftAlt = strlen(s:Left({'alt': 1}))
                                        let left = ''
                                        let right = ''
                                        if s:Multipart() && lenLeft >= lenLeftAlt
                                            let left = s:Left()
                                        elseif s:AltMultipart()
                                            let left = s:Left({'alt': 1})
                                        else
                                            return -1
                                        endif
                            
                                        "get the last char of left
                                        let sexyComMarker = strpart(left, strlen(left)-1)
   21              0.000011         endif
   21              0.000009     endif
                            
   21              0.000026     if a:space && g:NERDSpaceDelims
                                    let sexyComMarker = sexyComMarker . s:spaceStr
   21              0.000009     endif
                            
   21              0.000016     if a:esc
   21   0.000256   0.000159         let sexyComMarker = s:Esc(sexyComMarker)
   21              0.000011     endif
                            
   21              0.000021     return sexyComMarker

FUNCTION  ale#sign#ParseSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 204
Called 6 times
Total time:   0.000687
 Self time:   0.000619

count  total (s)   self (s)
    6   0.000110   0.000042     let l:pattern =ale#sign#ParsePattern()
    6              0.000007     let l:result = []
    6              0.000007     let l:is_dummy_sign_set = 0
                            
   21              0.000025     for l:line in a:line_list
   15              0.000303         let l:match = matchlist(l:line, l:pattern)
                            
   15              0.000026         if len(l:match) > 0
    3              0.000005             if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
    3              0.000002             else
    3              0.000015                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
    3              0.000001             endif
   15              0.000006         endif
   21              0.000021     endfor
                            
    6              0.000011     return [l:is_dummy_sign_set, l:result]

FUNCTION  164()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim line 592
Called 14 times
Total time:   0.060097
 Self time:   0.025338

count  total (s)   self (s)
   14   0.028450   0.000174     call self.path.refreshFlags(self.getNerdtree())
   46              0.000077     for i in self.children
   32   0.019997   0.000123         call i.refreshFlags()
   46              0.000031     endfor

FUNCTION  ale#handlers#eslint#FindConfig()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 12
Called 3 times
Total time:   0.003684
 Self time:   0.002222

count  total (s)   self (s)
   12   0.000842   0.000273     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
   57              0.000108         for l:basename in [   '.eslintrc.js',   '.eslintrc.yaml',   '.eslintrc.yml',   '.eslintrc.json',   '.eslintrc',]
   48   0.001626   0.000733             let l:config = ale#path#Simplify(join([l:path, l:basename], s:sep))
                            
   48              0.000864             if filereadable(l:config)
    3              0.000008                 return l:config
   45              0.000023             endif
   54              0.000035         endfor
    9              0.000005     endfor
                            
                                return ale#path#FindNearestFile(a:buffer, 'package.json')

FUNCTION  ale_linters#javascript#xo#GetExecutable()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/xo.vim line 8
Called 9 times
Total time:   0.007155
 Self time:   0.000134

count  total (s)   self (s)
    9   0.007145   0.000124     return ale#node#FindExecutable(a:buffer, 'javascript_xo', [   'node_modules/.bin/xo',])

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim line 29
Called 183 times
Total time:   0.130923
 Self time:   0.130923

count  total (s)   self (s)
  183              0.014489     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
  183              0.001127     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
  183              0.111908     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
  183              0.000670     if !empty(l:relative_path)
   24              0.001474         return fnamemodify(l:relative_path, ':p')
  159              0.000119     endif
                            
  159              0.000152     return ''

FUNCTION  32()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 584
Called 51 times
Total time:   0.014735
 Self time:   0.001463

count  total (s)   self (s)
   51   0.001051   0.000570     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
   51              0.000034     else
   51   0.013483   0.000693         return self.str() ==# a:path.str()
                                endif

FUNCTION  33()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 593
Called 3 times
Total time:   0.001673
 Self time:   0.000228

count  total (s)   self (s)
    3              0.000131     let l:newPath = copy(self)
                            
    3   0.001451   0.000046     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
    3              0.000006     let l:newPath.cachedDisplayString = ''
    3   0.000074   0.000033     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    3              0.000003     return l:newPath

FUNCTION  34()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 608
Called 281 times
Total time:   0.006890
 Self time:   0.004782

count  total (s)   self (s)
                            
  281   0.005118   0.003010     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
  281              0.000120     endif
                            
  281              0.000206     return '/'

FUNCTION  35()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 626
Called 6 times
Total time:   0.000419
 Self time:   0.000419

count  total (s)   self (s)
    6              0.000237     let tmp = resolve(a:path)
    6              0.000178     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  36()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 635
Called 3 times
Total time:   0.001259
 Self time:   0.000602

count  total (s)   self (s)
    3   0.000111   0.000017     call self.extractDriveLetter(a:fullpath)
                            
    3   0.000084   0.000020     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    3              0.000043     if getftype(fullpath) ==# 'fifo'
                                    throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
    3              0.000002     endif
                            
    3              0.000092     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
    3              0.000007     let self.isReadOnly = 0
    3              0.000030     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
    3              0.000082     elseif filereadable(a:fullpath)
    3              0.000006         let self.isDirectory = 0
    3              0.000078         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
    3              0.000001     endif
                            
    3              0.000004     let self.isExecutable = 0
    3              0.000004     if !self.isDirectory
    3              0.000034         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    3              0.000002     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    3   0.000061   0.000026     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    3   0.000308   0.000039     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    3   0.000224   0.000028     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
    3              0.000004     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
    3              0.000001     endif

FUNCTION  38()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 693
Called 34 times
Total time:   0.047919
 Self time:   0.000560

count  total (s)   self (s)
   34   0.045808   0.000388     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
   34   0.002092   0.000152     call self.cacheDisplayString()

FUNCTION  <SNR>49_evaluate_opts()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 289
Called 6 times
Total time:   0.000606
 Self time:   0.000194

count  total (s)   self (s)
    6   0.000603   0.000191   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  ale#handlers#tsserver#GetProjectRoot()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/tsserver.vim line 4
Called 9 times
Total time:   0.006432
 Self time:   0.000195

count  total (s)   self (s)
    9   0.006382   0.000146     let l:tsconfig_file = ale#path#FindNearestFile(a:buffer, 'tsconfig.json')
                            
    9              0.000028     return !empty(l:tsconfig_file) ? fnamemodify(l:tsconfig_file, ':h') : ''

FUNCTION  xolox#misc#msg#debug()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/msg.vim line 48
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    2              0.000005   if &vbs >= 1
                                call s:show_message('Question', a:000)
    2              0.000001   endif

FUNCTION  <SNR>169_csi()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 189
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   let prefix = a:fg ? '38;' : '48;'
    1              0.000003   if a:color[0] == '#'
                                return prefix.'2;'.join(map([a:color[1:2], a:color[3:4], a:color[5:6]], 'str2nr(v:val, 16)'), ';')
    1              0.000001   endif
    1              0.000003   return prefix.'5;'.a:color

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 71
Called 6 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
    6              0.000157     if !isdirectory(a:dir)
    6              0.000006         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  ale#util#Writefile()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 416
Called 15 times
Total time:   0.006144
 Self time:   0.006144

count  total (s)   self (s)
   15              0.000111     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
   15              0.006013     call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks

FUNCTION  <SNR>52_SwapOuterMultiPartDelimsForPlaceHolders()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 3064
Called 20 times
Total time:   0.005456
 Self time:   0.001583

count  total (s)   self (s)
                                " find out if the line is commented using normal delimiters and/or
                                " alternate ones
   20   0.002651   0.000590     let isCommented = s:IsCommented(s:Left(), s:Right(), a:line)
   20   0.002407   0.000596     let isCommentedAlt = s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), a:line)
                            
   20              0.000027     let line2 = a:line
                            
                                "if the line is commented and there is a right delimiter, replace
                                "the delimiters with place-holders
   20              0.000035     if isCommented && s:Multipart()
                                    let line2 = s:ReplaceDelims(s:Left(), s:Right(), g:NERDLPlace, g:NERDRPlace, a:line)
                            
                                "similarly if the line is commented with the alternative
                                "delimiters
   20              0.000037     elseif isCommentedAlt && s:AltMultipart()
                                    let line2 = s:ReplaceDelims(s:Left({'alt': 1}), s:Right({'alt': 1}), g:NERDLPlace, g:NERDRPlace, a:line)
   20              0.000009     endif
                            
   20              0.000018     return line2

FUNCTION  <SNR>41_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 377
Called 1 time
Total time:   0.039849
 Self time:   0.000184

count  total (s)   self (s)
    1              0.000002   if g:NERDTreeUpdateOnCursorHold != 1
                                return
    1              0.000000   endif
                            
    1   0.000068   0.000012   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
    1              0.000000   endif
                            
                              " Do not update when a special buffer is selected
    1              0.000003   if !empty(&l:buftype)
                                return
    1              0.000000   endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
    1              0.000003   let l:winnr = winnr()
    1              0.000002   let l:altwinnr = winnr('#')
                            
    1   0.000246   0.000008   call g:NERDTree.CursorToTreeWin()
    1   0.032594   0.000029   call b:NERDTree.root.refreshFlags()
    1   0.006815   0.000008   call NERDTreeRender()
                            
    1              0.000006   exec l:altwinnr . 'wincmd w'
    1              0.000098   exec l:winnr . 'wincmd w'

FUNCTION  40()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 743
Called 249 times
Total time:   0.029445
 Self time:   0.013416

count  total (s)   self (s)
  249              0.000562     let options = a:0 ? a:1 : {}
  249              0.000281     let toReturn = ''
                            
  249              0.000482     if has_key(options, 'format')
    2              0.000003         let format = options['format']
    2              0.000005         if has_key(self, '_strFor' . format)
    2   0.000036   0.000015             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
    2              0.000001         endif
  247              0.000105     else
  247   0.016540   0.001461         let toReturn = self._str()
  249              0.000139     endif
                            
  249   0.003228   0.002299     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
  249              0.000109     endif
                            
  249              0.000430     if has_key(options, 'truncateTo')
    2              0.000003         let limit = options['truncateTo']
    2              0.000006         if strdisplaywidth(toReturn) > limit-1
   64              0.000190             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
   62              0.000232                 let toReturn = substitute(toReturn, '^.', '', '')
   64              0.000032             endwhile
    2              0.000012             if len(split(toReturn, '/')) > 1
    2              0.000016                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
    2              0.000001             endif
    2              0.000001         endif
  249              0.000092     endif
                            
  249              0.000261     return toReturn

FUNCTION  41()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 780
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000010     let toReturn = '/' . join(self.pathSegments, '/')
    2              0.000004     if self.isDirectory && toReturn !=# '/'
    2              0.000003         let toReturn  = toReturn . '/'
    2              0.000001     endif
    2              0.000002     return toReturn

FUNCTION  45()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 838
Called 247 times
Total time:   0.015079
 Self time:   0.007301

count  total (s)   self (s)
  247   0.007522   0.001447     let l:separator = s:Path.Slash()
  247              0.000375     let l:leader = l:separator
                            
  247   0.004454   0.002752     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
  247              0.000113     endif
                            
  247              0.001866     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  48()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 878
Called 3 times
Total time:   0.000064
 Self time:   0.000042

count  total (s)   self (s)
    3   0.000045   0.000023     if !nerdtree#runningWindows()
    3              0.000004         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', 'g')
                            
                                return toReturn

FUNCTION  <SNR>169_escape()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 158
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   let path = fnameescape(a:path)
    1              0.000003   return s:is_win ? escape(path, '$') : path

FUNCTION  <SNR>105_resolve_parenthesis_from_config()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 39
Called 2 times
Total time:   0.000131
 Self time:   0.000029

count  total (s)   self (s)
    2   0.000130   0.000028 	return s:resolve_parenthesis_with(['', 0, '', a:config.contains_prefix, '', a:config.operators], a:config.parentheses_options)

FUNCTION  130()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim line 288
Called 20 times
Total time:   0.019874
 Self time:   0.000177

count  total (s)   self (s)
   20   0.019866   0.000169     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  133()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim line 319
Called 26 times
Total time:   0.014293
 Self time:   0.012529

count  total (s)   self (s)
   26              0.000022     let output = ''
   26              0.000021     if a:drawText ==# 1
                            
   24              0.000046         let treeParts = repeat('  ', a:depth - 1)
   24              0.000072         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
   24   0.001560   0.000148         let line = treeParts . self.displayString()
   24              0.000044         let output = output . line . "\n"
   26              0.000010     endif
                            
                                " if the node is an open dir, draw its children
   26              0.000029     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    2   0.004865   0.000014         let childNodesToDraw = self.getVisibleChildren()
                            
    2   0.004937   0.000047         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
    2              0.000004         elseif len(childNodesToDraw) > 0
   26              0.000019             for i in childNodesToDraw
   24              0.000069                 let output = output . i._renderToString(a:depth + 1, 1)
   26              0.000012             endfor
    2              0.000001         endif
   26              0.000008     endif
                            
   26              0.000019     return output

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 5
Called 43 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
   43              0.000176     return call('mode', a:000)

FUNCTION  <SNR>131_SkipFunc()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 110
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000001   if s:top_col == 1
                                throw 'out of bounds'
    1              0.000001   elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
    1              0.000012   elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
    1              0.000006   elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
    1              0.000000   else
    1              0.000006     let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
    1              0.000000   endif
    1              0.000004   let [s:looksyn, s:top_col] = getpos('.')[1:2]

FUNCTION  <SNR>105_concat()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 9
Called 30 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
   30              0.000369 	return join(filter(a:strs, "v:val !~ '^[ ]*$'"), ',')

FUNCTION  lightline#link()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 217
Called 255 times
Total time:   0.033912
 Self time:   0.033912

count  total (s)   self (s)
  255              0.003145   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
  255              0.000657   if s:mode ==# mode
  224              0.000267     return ''
   31              0.000037   endif
   31              0.000093   let s:mode = mode
   31              0.000114   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
   31              0.000035   endif
   31              0.000535   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   93              0.000406   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
  341              0.000909     for [i, t] in map(range(0, l), '[v:val, 0]') + types
  279              0.000268       if i != l
  217              0.004603         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
  279              0.000165       endif
 1550              0.003834       for [j, s] in map(range(0, l), '[v:val, 0]') + types
 1271              0.001914         if i + 1 == j || t || s && i != l
  589              0.010188           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
 1271              0.000627         endif
 1550              0.000658       endfor
  341              0.000208     endfor
   93              0.000108   endfor
   31              0.000480   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
   31              0.000044   return ''

FUNCTION  <SNR>75_FileUpdate()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 292
Called 3 times
Total time:   0.024325
 Self time:   0.000297

count  total (s)   self (s)
    3              0.000014     if g:NERDTreeUpdateOnWrite != 1
                                    return
    3              0.000002     endif
                            
    3   0.000246   0.000038     if !g:NERDTree.IsOpen()
                                    return
    3              0.000001     endif
                            
    3              0.000009     let l:winnr = winnr()
    3              0.000009     let l:altwinnr = winnr('#')
                            
    3   0.000575   0.000023     call g:NERDTree.CursorToTreeWin()
    3   0.023442   0.000173     let l:node = b:NERDTree.root.findNode(g:NERDTreePath.New(a:fname))
    3              0.000005     if l:node == {}
    3              0.000002         return
                                endif
                                call l:node.refreshFlags()
                                let l:node = l:node.parent
                                while !empty(l:node)
                                    call l:node.refreshDirFlags()
                                    let l:node = l:node.parent
                                endwhile
                            
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  <SNR>162_syntax_stack_at()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 21
Called 1 time
Total time:   0.000479
 Self time:   0.000479

count  total (s)   self (s)
    1              0.000478   return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')

FUNCTION  repeat#set()
    Defined: ~/.vim/plugged/vim-repeat/autoload/repeat.vim line 62
Called 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    1              0.000005     let g:repeat_sequence = a:sequence
    1              0.000003     let g:repeat_count = a:0 ? a:1 : v:count
    1              0.000002     let g:repeat_tick = b:changedtick
    1              0.000002     augroup repeat_custom_motion
    1              0.000186         autocmd!
    1              0.000005         autocmd CursorMoved <buffer> let g:repeat_tick = b:changedtick | autocmd! repeat_custom_motion
    1              0.000001     augroup END

FUNCTION  <SNR>51_fzf_vim_term()
    Defined: ~/.vim/plugged/fzf.vim/plugin/fzf.vim line 107
Called 2 times
Total time:   0.000458
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000007     if get(w:, 'airline_active', 0)
                                  let w:airline_disabled = 1
                                  autocmd BufWinLeave <buffer> let w:airline_disabled = 0
    2              0.000001     endif
    2              0.000025     autocmd WinEnter,ColorScheme <buffer> call s:fzf_restore_colors()
                            
    2              0.000012     setlocal nospell
    2   0.000404   0.000019     call s:fzf_restore_colors()

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 245
Called 3 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    3              0.000004     let l:msg = a:format_string
    3              0.000005     let l:severity = g:ale_echo_msg_warning_str
    3              0.000007     let l:code = get(a:item, 'code', '')
    3              0.000006     let l:type = get(a:item, 'type', 'E')
    3              0.000007     let l:linter_name = get(a:item, 'linter_name', '')
    3              0.000008     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    3              0.000004     if l:type is# 'E'
    3              0.000005         let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
    3              0.000001     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    3              0.000049     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
    3              0.000016     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    3              0.000012     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
    3              0.000016     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
    3              0.000003     return l:msg

FUNCTION  <SNR>52_IsCommented()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2499
Called 40 times
Total time:   0.002620
 Self time:   0.000764

count  total (s)   self (s)
                                "if the line isn't commented return true
   40   0.002498   0.000642     if s:FindDelimiterIndex(a:left, a:line) !=# -1 && (s:LastIndexOfDelim(a:right, a:line) !=# -1 || !s:Multipart())
                                    return 1
   40              0.000018     endif
   40              0.000024     return 0

FUNCTION  ale#handlers#eslint#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 32
Called 24 times
Total time:   0.031612
 Self time:   0.000426

count  total (s)   self (s)
   24   0.031593   0.000406     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [   'node_modules/.bin/eslint_d',   'node_modules/eslint/bin/eslint.js',   'node_modules/.bin/eslint',])

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 350
Called 6 times
Total time:   0.000595
 Self time:   0.000556

count  total (s)   self (s)
    6              0.000010     let l:command_list = []
    6              0.000009     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    6              0.000017     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    4   0.000124   0.000101         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    4              0.000005         let l:is_dummy_sign_set = 1
    6              0.000003     endif
                            
                                " Place new items first.
   10              0.000026     for [l:line_str, l:info] in items(a:sign_map)
    4              0.000004         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
    6              0.000006             for l:item in l:info.items
    3              0.000005                 let l:item.sign_id = l:info.new_id
    6              0.000003             endfor
                            
    3              0.000006             if index(l:info.current_id_list, l:info.new_id) < 0
    1   0.000025   0.000020                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    3              0.000003             endif
    4              0.000002         endif
   10              0.000012     endfor
                            
                                " Remove signs without new IDs.
   10              0.000017     for l:info in values(a:sign_map)
    7              0.000007         for l:current_id in l:info.current_id_list
    3              0.000004             if l:current_id isnot l:info.new_id
    1   0.000012   0.000010                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
    3              0.000001             endif
    7              0.000003         endfor
   10              0.000008     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    6              0.000009     if l:is_dummy_sign_set && !g:ale_sign_column_always
    4   0.000059   0.000051         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    6              0.000003     endif
                            
    6              0.000005     return l:command_list

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 14
Called 2 times
Total time:   0.000070
 Self time:   0.000050

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    2   0.000059   0.000039     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  ale#handlers#fecs#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/fecs.vim line 11
Called 9 times
Total time:   0.015432
 Self time:   0.000152

count  total (s)   self (s)
    9   0.015423   0.000144     return ale#node#FindExecutable(a:buffer, 'javascript_fecs', [   'node_modules/.bin/fecs',   'node_modules/fecs/bin/fecs',])

FUNCTION  140()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim line 95
Called 8 times
Total time:   0.000851
 Self time:   0.000316

count  total (s)   self (s)
    8              0.000009     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
    8              0.000007     let l:label = ''
    8   0.000379   0.000036     let l:cascade = self.getCascade()
   16              0.000017     for l:dirNode in l:cascade
    8   0.000076   0.000038         let l:next = l:dirNode.path.displayString()
    8              0.000039         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
   16              0.000012     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
    8              0.000022     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
    8              0.000019     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
    8   0.000198   0.000044     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
    8              0.000015     return l:symbol . l:flags . l:label

FUNCTION  141()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim line 120
Called 21 times
Total time:   0.031320
 Self time:   0.009703

count  total (s)   self (s)
   21   0.005816   0.000165     if a:path.equals(self.path)
                                    return self
   21              0.000010     endif
   21   0.005308   0.000278     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   15              0.000016         return {}
    6              0.000002     endif
                            
    6              0.000007     if self.path.isDirectory
   54              0.000178         for i in self.children
   48   0.009870   0.000378             let retVal = i.findNode(a:path)
   48              0.000103             if retVal !=# {}
                                            return retVal
   48              0.000025             endif
   54              0.000066         endfor
    6              0.000003     endif
    6              0.000005     return {}

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 81
Called 9 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    9              0.000023     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
    9              0.000005     endif
                            
    9              0.000007     return 0

FUNCTION  <SNR>162_start_syntax()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 36
Called 1 time
Total time:   0.000027
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000027   0.000014   return s:syntax_at(a:lnum, s:start_col(a:lnum))

FUNCTION  <SNR>164_RunJob()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 129
Called 6 times
Total time:   0.020228
 Self time:   0.000730

count  total (s)   self (s)
    6   0.000093   0.000060     if ale#command#IsDeferred(a:result)
                                    let a:result.result_callback = {x -> s:RunJob(x, a:options)}
                            
                                    return
    6              0.000013     endif
                            
    6              0.000011     let l:buffer = a:options.buffer
    6              0.000010     let l:input = a:options.input
                            
    6              0.000024     if a:result is 0 || type(a:result) is v:t_list
                                    if type(a:result) is v:t_list
                                        let l:input = a:result
                                    endif
                            
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + 1,   'callback_list': a:options.callback_list,})
                            
                                    return
    6              0.000002     endif
                            
    6              0.000021     let l:command = get(a:result, 'command', '')
    6              0.000016     let l:ChainWith = get(a:result, 'chain_with', v:null)
                            
    6              0.000011     if empty(l:command)
                                    " If the command is empty, skip to the next item, or call the
                                    " chain_with function.
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + (l:ChainWith is v:null),   'callback_list': a:options.callback_list,   'chain_callback': l:ChainWith,   'output': [],})
                            
                                    return
    6              0.000002     endif
                            
    6              0.000018     let l:read_temporary_file = get(a:result, 'read_temporary_file', 0)
                                " Default to piping the buffer for the last fixer in the chain.
    6              0.000019     let l:read_buffer = get(a:result, 'read_buffer', l:ChainWith is v:null)
    6              0.000016     let l:output_stream = get(a:result, 'output_stream', 'stdout')
                            
    6              0.000006     if l:read_temporary_file
                                    let l:output_stream = 'none'
    6              0.000003     endif
                            
    6              0.000086     let l:Callback = function('s:HandleExit', [{   'input': l:input,   'chain_with': l:ChainWith,   'callback_index': a:options.callback_index,   'callback_list': a:options.callback_list,   'process_with': get(a:result, 'process_with', v:null),   'read_temporary_file': l:read_temporary_file,}])
    6   0.019628   0.000162     let l:run_result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': '',   'read_buffer': l:read_buffer,   'input': l:input,   'log_output': 0,})
                            
    6              0.000014     if empty(l:run_result)
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + 1,   'callback_list': a:options.callback_list,})
    6              0.000003     endif

FUNCTION  152()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim line 358
Called 12 times
Total time:   0.009763
 Self time:   0.000924

count  total (s)   self (s)
   12              0.000015     let toReturn = []
   76              0.000063     for i in self.children
   64   0.009399   0.000560         if i.path.ignore(self.getNerdtree()) ==# 0
   48              0.000094             call add(toReturn, i)
   64              0.000029         endif
   76              0.000039     endfor
   12              0.000009     return toReturn

FUNCTION  154()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim line 380
Called 10 times
Total time:   0.005187
 Self time:   0.000227

count  total (s)   self (s)
   10              0.000014     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
   10              0.000004     endif
                            
   10              0.000009     if self.path.isSymLink
                                    return 0
   10              0.000003     endif
                            
   10   0.000110   0.000063     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
   10              0.000010     endfor
                            
   10   0.004957   0.000045     let c = self.getVisibleChildren()
   10              0.000019     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  <SNR>96_line()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 401
Called 28 times
Total time:   0.033120
 Self time:   0.013821

count  total (s)   self (s)
   28              0.000066   let _ = a:tabline ? '' : '%{lightline#link()}'
   28              0.000063   if s:lightline.palette == {}
                                call lightline#colorscheme()
   28              0.000012   endif
   28              0.000137   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   28              0.000128   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   28              0.000140   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
   28              0.000066   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   28              0.000135   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   28   0.008279   0.000632   let [lt, lc, ll] = s:expand(copy(l_))
   28              0.000201   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   28   0.008669   0.000546   let [rt, rc, rl] = s:expand(copy(r_))
   70              0.000129   for i in range(len(lt))
   42              0.000190     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
  126              0.000205     for j in range(len(lt[i]))
   84              0.000744       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
   84              0.000813       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   84              0.000231       if j < len(lt[i]) - 1 && s.left !=# ''
   42   0.002888   0.000726         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
   84              0.000058       endif
  126              0.000078     endfor
   42              0.000231     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
   42              0.000311     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
   70              0.000080   endfor
   28              0.000083   let _ .= '%#LightlineMiddle_' . mode . '#%='
   98              0.000163   for i in range(len(rt) - 1, 0, -1)
   70              0.000391     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
   70              0.000477     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
   70              0.000319     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
  168              0.000300     for j in range(len(rt[i]))
   98              0.000765       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
   98              0.000749       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   98              0.000253       if j < len(rt[i]) - 1 && s.right !=# ''
   28   0.001836   0.000470         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
   98              0.000060       endif
  168              0.000092     endfor
   98              0.000086   endfor
   28              0.000038   return _

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 24
Called 43 times
Total time:   0.000483
 Self time:   0.000483

count  total (s)   self (s)
   43              0.000263     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   43              0.000156     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 42
Called 6 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    6              0.000047     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>26_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/ftplugin.vim line 14
Called 2 times
Total time:   0.009762
 Self time:   0.009762

count  total (s)   self (s)
    2              0.000007     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000001     endif
                            
    2              0.000009     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000023       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000033       for name in split(s, '\.')
    2              0.009644 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    4              0.000009       endfor
    2              0.000002     endif

FUNCTION  <SNR>49_use_sh()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 355
Called 4 times
Total time:   0.000131
 Self time:   0.000126

count  total (s)   self (s)
    4              0.000039   let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
    4              0.000005   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
    4              0.000003   else
    4   0.000033   0.000029     set shell=sh
    4              0.000003   endif
    4              0.000015   return [shell, shellslash, shellcmdflag, shellxquote]

FUNCTION  <SNR>75_NERDTreeTrimDoubleQuotes()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 139
Called 4 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    4              0.000024     let l:toReturn = substitute(a:pathStr, '^"', '', '')
    4              0.000017     let l:toReturn = substitute(l:toReturn, '"$', '', '')
    4              0.000005     return l:toReturn

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 100
Called 21 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   21              0.000064     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   21              0.000110     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  NERDTreeRender()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim line 214
Called 2 times
Total time:   0.013445
 Self time:   0.000016

count  total (s)   self (s)
    2   0.013444   0.000015     call nerdtree#renderView()

FUNCTION  <SNR>52_IsNumEven()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2646
Called 8 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    8              0.000016     return (a:num % 2) ==# 0

FUNCTION  <SNR>49_pushd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 472
Called 3 times
Total time:   0.001395
 Self time:   0.000582

count  total (s)   self (s)
    3   0.000059   0.000026   if s:present(a:dict, 'dir')
    3   0.000324   0.000044     let cwd = s:fzf_getcwd()
    3              0.000039     let w:fzf_pushd = {   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),   'origin': cwd,   'bufname': bufname('') }
    3   0.000884   0.000417     execute 'lcd' s:escape(a:dict.dir)
    3   0.000059   0.000025     let cwd = s:fzf_getcwd()
    3              0.000008     let w:fzf_pushd.dir = cwd
    3              0.000011     let a:dict.pushd = w:fzf_pushd
    3              0.000003     return cwd
                              endif
                              return ''

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 186
Called 287 times
Total time:   0.003907
 Self time:   0.003907

count  total (s)   self (s)
  287              0.000894     let l:full_name = 'ale_' . a:variable_name
  287              0.001466     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  287              0.001170     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>159_SetListsImpl()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim line 78
Called 6 times
Total time:   0.002266
 Self time:   0.001342

count  total (s)   self (s)
    6              0.000515     let l:title = expand('#' . a:buffer . ':p')
                            
    6              0.000009     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    6              0.000006     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    6   0.000123   0.000083         let l:ids = s:WinFindBuf(a:buffer)
                            
   12              0.000015         for l:id in l:ids
    6              0.000016             if has('nvim')
    6   0.000547   0.000115                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
    6              0.000003             endif
   12              0.000011         endfor
    6              0.000003     endif
                            
                                " Save the current view before opening/closing any window
    6              0.000056     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    6   0.000170   0.000051     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    6              0.000003     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    6   0.000100   0.000046     if !ale#engine#IsCheckingBuffer(a:buffer)
    6   0.000330   0.000049         call s:CloseWindowIfNeeded(a:buffer)
    6              0.000003     endif

FUNCTION  <SNR>49_fzf_getcwd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 102
Called 11 times
Total time:   0.000557
 Self time:   0.000094

count  total (s)   self (s)
   11   0.000548   0.000085   return s:fzf_call('getcwd')

FUNCTION  <SNR>155_syn_name()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim line 28
Called 37 times
Total time:   0.005410
 Self time:   0.005410

count  total (s)   self (s)
   37              0.005233   let syn_id = get(synstack(a:lnum, a:cnum), -1)
   37              0.000142   return synIDattr(syn_id, "name")

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 590
Called 34 times
Total time:   0.014652
 Self time:   0.003861

count  total (s)   self (s)
   34              0.000060   let path = a:event.subject
   34              0.000061   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
   34              0.000051   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
   34   0.000454   0.000240   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
   34              0.000106   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
   34   0.000669   0.000439   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
   34              0.000071   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
   32              0.000080     let prePadding .= ' '
   34              0.000014   endif
                            
   34              0.000030   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
   20   0.006244   0.000406     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
   14              0.000022   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
   14              0.000017     let directoryOpened = 0
                            
   14              0.000052     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
   14              0.000005     endif
                            
   14              0.000019     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
   14              0.000016       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
   14              0.000007       else
                                    " the folder is not open
   14              0.000013         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
   14              0.000006         else
                                      " We have a regular folder
   14   0.004061   0.000288           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
   14              0.000006         endif
   14              0.000005       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
   14              0.000005     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
   34              0.000014   endif
                            
   34   0.000356   0.000197   call path.flagSet.clearFlags('webdevicons')
                            
   34              0.000042   if flag !=? ''
   34   0.000761   0.000183     call path.flagSet.addFlag('webdevicons', flag)
   34              0.000014   endif
                            

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 140
Called 15 times
Total time:   0.015141
 Self time:   0.003879

count  total (s)   self (s)
   15              0.000024     let l:temporary_file = ''
   15              0.000019     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   15              0.000117     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
   15              0.000054     if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
   15              0.000007     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   15              0.000039     if l:command =~# '%s'
   15              0.001104         let l:filename = fnamemodify(bufname(a:buffer), ':p')
   15   0.000579   0.000301         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
   15              0.000009     endif
                            
   15              0.000066     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
   15              0.000007     endif
                            
                                " Finish formatting so %% becomes %.
   15              0.000086     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   15              0.000038     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
   15   0.000946   0.000227         let l:temporary_file = s:TemporaryFilename(a:buffer)
   15   0.000325   0.000130         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
   15              0.000008     endif
                            
   15   0.011398   0.001327     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
   15              0.000057     return [l:temporary_file, l:command, l:file_created]

FUNCTION  83()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim line 35
Called 44 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
   44              0.000104     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
   44              0.000018     endif
   44              0.000041     return g:NERDTreeBookmarks

FUNCTION  <SNR>49_split()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 644
Called 2 times
Total time:   0.014725
 Self time:   0.001110

count  total (s)   self (s)
    2              0.000024   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    2   0.000036   0.000015   let ppos = s:getpos()
    2              0.000002   try
    2   0.000053   0.000017     if s:present(a:dict, 'window')
                                  if type(a:dict.window) == type({})
                                    if !has('nvim') && !has('patch-8.2.191')
                                      throw 'Vim 8.2.191 or later is required for pop-up window'
                                    end
                                    call s:popup(a:dict.window)
                                  else
                                    execute 'keepalt' a:dict.window
                                  endif
    2   0.000085   0.000032     elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
    2              0.000001     else
    8              0.000020       for [dir, triple] in items(directions)
    8              0.000021         let val = get(a:dict, dir, '')
    8              0.000013         if !empty(val)
    2              0.000005           let [cmd, resz, max] = triple
    2              0.000008           if (dir == 'up' || dir == 'down') && val[0] == '~'
    2   0.000262   0.000020             let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
    2              0.000001           endif
    2   0.013987   0.000734           execute cmd sz.'new'
    2              0.000014           execute resz sz
    2              0.000006           return [ppos, {}]
    6              0.000003         endif
    6              0.000003       endfor
                                endif
                                return [ppos, { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }]
    2              0.000002   finally
    2   0.000034   0.000024     setlocal winfixwidth winfixheight
    2              0.000003   endtry

FUNCTION  rainbow#hi()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 98
Called 2 times
Total time:   0.001589
 Self time:   0.001364

count  total (s)   self (s)
    2              0.000005 	let conf = a:config
    2              0.000003 	let prefix = conf.syn_name_prefix
                            
    8              0.000016 	for id in range(len(conf.parentheses))
   30              0.000038 		for lv in range(conf.cycle)
   24   0.000659   0.000433 			let [pid, oid] = [s:synID(prefix, 'p', lv, id), s:synID(prefix, 'o', lv, id)]
   24              0.000089 			let ctermfg = conf.ctermfgs[lv % len(conf.ctermfgs)]
   24              0.000052 			let guifg = conf.guifgs[lv % len(conf.guifgs)]
   24              0.000044 			let cterm = conf.cterms[lv % len(conf.cterms)]
   24              0.000063 			let gui = conf.guis[lv % len(conf.guis)]
   24              0.000161 			let hi_style = 'ctermfg='.ctermfg.' guifg='.guifg.(len(cterm) > 0 ? ' cterm='.cterm : '').(len(gui) > 0 ? ' gui='.gui : '')
   24              0.000165 			exe 'hi '.pid.' '.hi_style
   24              0.000109 			exe 'hi '.oid.' '.hi_style
   30              0.000019 		endfor
    8              0.000007 	endfor

FUNCTION  ale#command#Run()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 252
Called 15 times
Total time:   0.048420
 Self time:   0.003823

count  total (s)   self (s)
   15              0.000050     let l:options = get(a:000, 0, {})
                            
   15              0.000026     if len(a:000) > 1
                                    throw 'Too many arguments!'
   15              0.000007     endif
                            
   15              0.000043     let l:output_stream = get(l:options, 'output_stream', 'stdout')
   15              0.000017     let l:line_list = []
                            
   15   0.015509   0.000369     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),)
   15   0.001390   0.000256     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
   15              0.000228     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
   15              0.000029     if l:output_stream is# 'stdout'
    6              0.000043         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    9              0.000014     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    9              0.000011     elseif l:output_stream is# 'both'
    9              0.000055         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    9              0.000036         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
   15              0.000008     endif
                            
   15              0.000019     let l:status = 'failed'
                            
   15              0.000035     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
   15              0.000047     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
   15              0.000008     else
   15   0.027237   0.000301         let l:job_id = ale#job#Start(l:command, l:job_options)
   15              0.000019     endif
                            
   15              0.000011     if l:job_id
   15              0.000034         let l:status = 'started'
   15              0.000080         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
   15   0.000576   0.000460         call ale#command#InitData(a:buffer)
   15              0.000063         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
   15              0.000007     endif
                            
   15              0.000020     if g:ale_history_enabled
   15   0.001449   0.000180         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
   15              0.000019     endif
                            
   15              0.000015     if !l:job_id
                                    return 0
   15              0.000007     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
   15              0.000139     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
   15              0.000043     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
   15              0.000007     endif
                            
   15              0.000026     return l:result

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 10
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000018     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 69
Called 2 times
Total time:   0.000721
 Self time:   0.000063

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    2              0.000012     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    2              0.000010     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
    2              0.000010         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
    2              0.000003         if g:ale_lint_on_filetype_changed
    2   0.000675   0.000017             call ale#Queue(300, 'lint_file', a:buffer)
    2              0.000001         endif
    2              0.000001     endif

FUNCTION  280()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 705
Called 1 time
Total time:   0.029244
 Self time:   0.001456

count  total (s)   self (s)
    1   0.000023   0.000012     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000003       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.020982   0.001161         close
    1              0.000001       endif
    1              0.000007       silent! execute 'tabnext' self.ppos.tab
    1   0.006541   0.000076       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000002     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000000     endif
                            
    1   0.000021   0.000012     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000109       execute self.winrest
    1              0.000001     endif
                            
    1   0.000030   0.000011     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000000     endif
                            
    1   0.000371   0.000007     call s:pushd(self.dict)
    1   0.000254   0.000012     let lines = s:collect(self.temps)
    1   0.000850   0.000011     call s:callback(self.dict, lines)
    1   0.000031   0.000012     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 377
Called 87 times
Total time:   0.000417
 Self time:   0.000417

count  total (s)   self (s)
   87              0.000368     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/cursorhold.vim line 48
Called 1 time
Total time:   0.000162
 Self time:   0.000108

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    2              0.000007   for handler in g:xolox#misc#cursorhold#handlers
    1              0.000004     let function = handler['function']
    1              0.000004     let last_run = get(handler, 'last_run', 0)
    1              0.000002     let interval = get(handler, 'interval', 4)
    1   0.000032   0.000017     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
    1              0.000006     let time_until_next_run = (last_run + interval) - localtime()
    1              0.000001     if time_until_next_run > 0
                                  call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
    1              0.000001     else
    1   0.000023   0.000013       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    1   0.000046   0.000017       call call(function, get(handler, 'arguments', []))
    1              0.000003       let handler['last_run'] = localtime()
    1              0.000001     endif
    2              0.000004   endfor

FUNCTION  <SNR>164_GetCallbacks()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 273
Called 3 times
Total time:   0.000954
 Self time:   0.000640

count  total (s)   self (s)
    3              0.000008     if len(a:fixers)
                                    let l:callback_list = a:fixers
    3              0.000013     elseif type(get(b:, 'ale_fixers')) is v:t_list
                                    " Lists can be used for buffer-local variables only
                                    let l:callback_list = b:ale_fixers
    3              0.000002     else
                                    " buffer and global options can use dictionaries mapping filetypes to
                                    " callbacks to run.
    3   0.000061   0.000022         let l:fixers = ale#Var(a:buffer, 'fixers')
    3              0.000009         let l:callback_list = []
    3              0.000004         let l:matched = 0
                            
    6              0.000037         for l:sub_type in split(&filetype, '\.')
    3   0.000112   0.000066             if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
    3              0.000004                 let l:matched = 1
    3              0.000002             endif
    6              0.000007         endfor
                            
                                    " If we couldn't find fixers for a filetype, default to '*' fixers.
    3              0.000003         if !l:matched
                                        call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
    3              0.000002         endif
    3              0.000001     endif
                            
    3              0.000005     if a:fixing_flag is# 'save_file'
    3   0.000064   0.000022         let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
                            
    3              0.000005         if !empty(l:config)
                                        call s:IgnoreFixers(l:callback_list, &filetype, l:config)
    3              0.000002         endif
    3              0.000001     endif
                            
    3              0.000005     let l:corrected_list = []
                            
                                " Variables with capital characters are needed, or Vim will complain about
                                " funcref variables.
    9              0.000014     for l:Item in l:callback_list
    6              0.000014         if type(l:Item) is v:t_string
    6   0.000236   0.000089             let l:Func = ale#fix#registry#GetFunc(l:Item)
                            
    6              0.000016             if !empty(l:Func)
    6              0.000010                 let l:Item = l:Func
    6              0.000004             endif
    6              0.000003         endif
                            
    6              0.000004         try
    6   0.000132   0.000090             call add(l:corrected_list, ale#util#GetFunction(l:Item))
                                    catch /E475/
                                        " Rethrow exceptions for failing to get a function so we can print
                                        " a friendly message about it.
                                        throw 'BADNAME ' . v:exception
    6              0.000005         endtry
    9              0.000012     endfor
                            
    3              0.000004     return l:corrected_list

FUNCTION  <SNR>49_getpos()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 640
Called 7 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    7              0.000065   return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  ale_linters#javascript#standard#GetExecutable()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/standard.vim line 8
Called 9 times
Total time:   0.028975
 Self time:   0.000132

count  total (s)   self (s)
    9   0.028969   0.000126     return ale#node#FindExecutable(a:buffer, 'javascript_standard', [   'node_modules/standardx/bin/cmd.js',   'node_modules/standard/bin/cmd.js',   'node_modules/semistandard/bin/cmd.js',   'node_modules/.bin/standard',])

FUNCTION  <SNR>169_extend_opts()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 49
Called 4 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    4              0.000008   if empty(a:eopts)
                                return
    4              0.000002   endif
    4              0.000009   if has_key(a:dict, 'options')
    2              0.000009     if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
    2              0.000002       if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
    2              0.000001       else
    2              0.000006         call extend(a:dict.options, a:eopts)
    2              0.000001       endif
                                else
                                  let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                  let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
    2              0.000001     endif
    2              0.000001   else
    2              0.000005     let a:dict.options = a:eopts
    4              0.000002   endif

FUNCTION  rainbow#load()
    Defined: ~/.vim/plugged/vim-rainbow/plugin/rainbow.vim line 49
Called 2 times
Total time:   0.010973
 Self time:   0.010301

count  total (s)   self (s)
    2              0.000006     if exists('b:loaded')
                                    cal rainbow#clear()
    2              0.000001     endif
                            
    2              0.000002     if a:0 >= 1
                                    let b:loaded = a:1
    2              0.000012     elseif &ft == 'cpp'
                                    let b:loaded = [ ['(', ')'], ['\[', '\]'], ['{', '}'], ['\v%(<operator\_s*)@<!%(%(\i|^\_s*|template\_s*)@<=\<[<#=]@!|\<@<!\<[[:space:]<#=]@!)', '\v%(-)@<!\>'] ]
    2              0.000012     elseif &ft == 'rust' || &ft == 'cs' || &ft == 'java'
                                    let b:loaded = [ ['(', ')'], ['\[', '\]'], ['{', '}'], ['\v%(\i|^\_s*)@<=\<[<#=]@!|\<@<!\<[[:space:]<#=]@!', '\v%(-)@<!\>'] ]
    2              0.000001     else
    2              0.000007         let b:loaded = [ ['(', ')'], ['\[', '\]'], ['{', '}'] ]
    2              0.000001     endif
                            
    2              0.000005     let b:operators = (a:0 < 2) ? '"\v[{\[(<_"''`#*/>)\]}]@![[:punct:]]|\*/@!|/[/*]@!|\<#@!|#@<!\>"' : a:2
                            
    2              0.000003     if b:operators != ''
    2              0.000048         exe 'syn match op_lv0 '.b:operators
    2              0.000003         let cmd = 'syn match %s %s containedin=%s contained'
    8              0.000013         for [left , right] in b:loaded
  102              0.000126             for each in range(1, s:max)
   96              0.001461                 exe printf(cmd, 'op_lv'.each, b:operators, 'lv'.each)
  102              0.000055             endfor
    8              0.000006         endfor
    2              0.000001     endif
                            
    2              0.000003     let str = 'TOP'
   34              0.000027     for each in range(1, s:max)
   32              0.000052         let str .= ',lv'.each
   34              0.000014     endfor
                            
    2              0.000004     let cmd = 'syn region %s matchgroup=%s start=+%s+ end=+%s+ containedin=%s contains=%s,%s,@Spell fold'
    8              0.000013     for [left , right] in b:loaded
  102              0.000110         for each in range(1, s:max)
   96              0.008102             exe printf(cmd, 'lv'.each, 'lv'.each.'c', left, right, 'lv'.(each % s:max + 1), str, 'op_lv'.each)
  102              0.000068         endfor
    8              0.000006     endfor
                            
    2   0.000697   0.000025     cal rainbow#activate()

FUNCTION  ale#path#BufferCdString()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim line 84
Called 3 times
Total time:   0.000328
 Self time:   0.000218

count  total (s)   self (s)
    3   0.000326   0.000216     return ale#path#CdString(fnamemodify(bufname(a:buffer), ':p:h'))

FUNCTION  <SNR>144_RunJob()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 438
Called 9 times
Total time:   0.030654
 Self time:   0.001449

count  total (s)   self (s)
    9   0.000109   0.000072     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    9              0.000004     endif
                            
    9              0.000013     let l:command = a:command
                            
    9              0.000014     if empty(l:command)
                                    return 0
    9              0.000003     endif
                            
    9              0.000015     let l:executable = a:options.executable
    9              0.000011     let l:buffer = a:options.buffer
    9              0.000010     let l:linter = a:options.linter
    9              0.000013     let l:output_stream = a:options.output_stream
    9              0.000014     let l:next_chain_index = a:options.next_chain_index
    9              0.000012     let l:read_buffer = a:options.read_buffer
    9              0.000020     let l:info = g:ale_buffer_info[l:buffer]
                            
    9              0.000100     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,   'next_chain_index': l:next_chain_index,}])
    9   0.029213   0.000259     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),})
                            
                                " Only proceed if the job is being run.
    9              0.000019     if empty(l:result)
                                    return 0
    9              0.000004     endif
                            
    9   0.000390   0.000229     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    9   0.000558   0.000505     silent doautocmd <nomodeline> User ALEJobStarted
                            
    9              0.000023     return 1

FUNCTION  fzf#shellescape()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 94
Called 24 times
Total time:   0.000563
 Self time:   0.000462

count  total (s)   self (s)
   24              0.000076   let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
   24              0.000091   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
   24              0.000012   endif
   24   0.000309   0.000208   return s:fzf_call('shellescape', a:arg)

FUNCTION  rainbow_main#load()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow_main.vim line 108
Called 2 times
Total time:   0.009264
 Self time:   0.000099

count  total (s)   self (s)
    2   0.000361   0.000022 	let b:rainbow_confs = rainbow_main#gen_configs(&filetype)
    4              0.000006 	for conf in b:rainbow_confs
    2   0.007268   0.000032 		call rainbow#syn(conf)
    2   0.001616   0.000027 		call rainbow#hi(conf)
    4              0.000003 	endfor

FUNCTION  <SNR>150_NeoVimCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim line 29
Called 61 times
Total time:  32.583360
 Self time:   0.004348

count  total (s)   self (s)
   61              0.000494     let l:info = s:job_map[a:job]
                            
   61              0.000137     if a:event is# 'stdout'
   37   0.025389   0.001367         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
   24              0.000037     elseif a:event is# 'stderr'
    9   0.000575   0.000216         let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
   15              0.000010     else
   15              0.000057         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
   15              0.000008         endif
                            
   15              0.000034         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
   15              0.000005         endif
                            
   15              0.000009         try
   15  32.554862   0.000231             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
   15              0.000015         finally
                                        " Automatically forget about the job after it's done.
   15              0.000041             if has_key(s:job_map, a:job)
   15              0.000040                 call remove(s:job_map, a:job)
   15              0.000007             endif
   15              0.000010         endtry
   61              0.000025     endif

FUNCTION  20()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 372
Called 213 times
Total time:   0.001554
 Self time:   0.001554

count  total (s)   self (s)
  213              0.000308     if empty(self.pathSegments)
                                    return ''
  213              0.000071     endif
  213              0.000287     let toReturn = self.pathSegments[-1]
  213              0.000197     if a:dirSlash && self.isDirectory
   14              0.000025         let toReturn = toReturn . '/'
  213              0.000071     endif
  213              0.000155     return toReturn

FUNCTION  ale#path#CdString()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim line 74
Called 12 times
Total time:   0.000462
 Self time:   0.000280

count  total (s)   self (s)
   12              0.000054     if has('win32')
                                    return 'cd /d ' . ale#Escape(a:directory) . ' && '
   12              0.000010     else
   12   0.000358   0.000176         return 'cd ' . ale#Escape(a:directory) . ' && '
                                endif

FUNCTION  xolox#session#auto_save_periodic()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim line 486
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
    1              0.000002   if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
    1              0.000000   endif

FUNCTION  <SNR>162_is_jsx_backticks()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 92
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return a:syntax =~? 'jsxBackticks'

FUNCTION  ale#util#SetBufferContents()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 485
Called 2 times
Total time:  32.417687
 Self time:  32.417681

count  total (s)   self (s)
    2   0.000019   0.000013     let l:has_bufline_api = ale#util#HasBuflineApi()
                            
    2              0.000004     if !l:has_bufline_api && a:buffer isnot bufnr('')
                                    return
    2              0.000001     endif
                            
                                " If the file is in DOS mode, we have to remove carriage returns from
                                " the ends of lines before calling setline(), or we will see them
                                " twice.
    2              0.000012     let l:new_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r\+$'', '''', '''')')   : a:lines
    2              0.000005     let l:first_line_to_remove = len(l:new_lines) + 1
                            
                                " Use a Vim API for setting lines in other buffers, if available.
    2              0.000002     if l:has_bufline_api
    2             32.417565         call setbufline(a:buffer, 1, l:new_lines)
    2              0.000022         call deletebufline(a:buffer, l:first_line_to_remove, '$')
                                " Fall back on setting lines the old way, for the current buffer.
                                else
                                    let l:old_line_length = line('$')
                            
                                    if l:old_line_length >= l:first_line_to_remove
                                        let l:save = winsaveview()
                                        silent execute   l:first_line_to_remove . ',' . l:old_line_length . 'd_'
                                        call winrestview(l:save)
                                    endif
                            
                                    call setline(1, l:new_lines)
    2              0.000001     endif
                            
    2              0.000003     return l:new_lines

FUNCTION  ale#Queue()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 129
Called 16 times
Total time:   0.083831
 Self time:   0.001081

count  total (s)   self (s)
   16              0.000023     if a:0 > 2
                                    throw 'too many arguments!'
   16              0.000009     endif
                            
   16              0.000068     let l:buffer = get(a:000, 1, v:null)
                            
   16              0.000023     if l:buffer is v:null
   12              0.000026         let l:buffer = bufnr('')
   16              0.000009     endif
                            
   16              0.000036     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
   16              0.000007     endif
                            
   16   0.001919   0.000193     if ale#ShouldDoNothing(l:buffer)
    3              0.000002         return
   13              0.000004     endif
                            
                                " Default linting_flag to ''
   13              0.000049     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
   13              0.000017     if s:lint_timer != -1
    9              0.000024         call timer_stop(s:lint_timer)
    9              0.000096         let s:lint_timer = -1
   13              0.000098     endif
                            
   13              0.000014     if a:delay > 0
    9              0.000099         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    4              0.000002     else
    4   0.081094   0.000068         call s:Lint(l:buffer, l:should_lint_file, 0)
   13              0.000006     endif

FUNCTION  <SNR>162_syntax_context()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 194
Called 1 time
Total time:   0.000610
 Self time:   0.000112

count  total (s)   self (s)
    1   0.000014   0.000007   let start_col = s:start_col(a:lnum)
    1   0.000488   0.000009   let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
    1              0.000003   let start_syntax = syntax_stack[-1]
    1              0.000002   let reversed = reverse(syntax_stack)
    1              0.000001   let i = 0
                            
    2              0.000003   for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
    1   0.000015   0.000010     if s:is_jsx_expression(syntax_name)
                                  return 'jsxExpressionBlock'
    1              0.000001     endif
                            
    1   0.000027   0.000023     if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
    1              0.000000     endif
                            
    1   0.000012   0.000008     if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
                                  if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
                                    if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
                                    elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
                                    else
                                      return 'jsxElement'
                                    endif
                                  elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
                                  else
                                    return 'jsxElement'
                                  endif
    1              0.000000     endif
                            
    1              0.000001     let i = i + 1
    2              0.000004   endfor
                              
    1              0.000001   return 'Other'

FUNCTION  <SNR>49_exit_handler()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 536
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000004   if a:code == 130
                                return 0
    2              0.000008   elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
    1              0.000001     return 0
    1              0.000001   elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
    1              0.000000   endif
    1              0.000001   return 1

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 52
Called 72 times
Total time:   0.006920
 Self time:   0.004765

count  total (s)   self (s)
   72              0.000146     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
    9              0.000007         return 0
   63              0.000026     endif
                            
                                " Check for a cached executable() check.
   63              0.000249     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   63              0.000088     if l:result isnot v:null
    9              0.000007         return l:result
   54              0.000022     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
   54              0.002602     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
   54              0.000172     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
   54              0.000025     endif
                            
   54              0.000071     if g:ale_history_enabled
   54   0.002857   0.000702         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
   54              0.000031     endif
                            
   54              0.000054     return l:result

FUNCTION  ale#Escape()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 225
Called 60 times
Total time:   0.000908
 Self time:   0.000908

count  total (s)   self (s)
   60              0.000268     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
   60              0.000033     endif
                            
   60              0.000203     return shellescape (a:str)

FUNCTION  <SNR>52_CanToggleCommentLine()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2032
Called 20 times
Total time:   0.013783
 Self time:   0.001566

count  total (s)   self (s)
   20              0.000057     let theLine = getline(a:lineNum)
   20   0.005942   0.000937     if (s:IsCommentedFromStartOfLine(s:Left(), theLine) || s:IsCommentedFromStartOfLine(s:Left({'alt': 1}), theLine)) && !a:forceNested
                                    return 0
   20              0.000009     endif
                            
                                " make sure we don't comment lines that are just spaces or tabs or empty,
                                " unless configured otherwise
   20              0.000126     if g:NERDCommentEmptyLines ==# 0 && theLine =~# "^[ \t]*$"
                                    return 0
   20              0.000008     endif
                            
                                "if the line is part of a sexy comment then just flag it...
   20   0.007466   0.000255     if s:IsInSexyComment(a:lineNum)
                                    return 0
   20              0.000010     endif
                            
   20              0.000012     return 1

FUNCTION  rainbow_main#gen_configs()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow_main.vim line 104
Called 2 times
Total time:   0.000340
 Self time:   0.000048

count  total (s)   self (s)
    2   0.000339   0.000047 	return filter(map(split(a:ft, '\v\.'), 'rainbow_main#gen_config(v:val)'), 'type(v:val) == type({})')

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 212
Called 622 times
Total time:   0.004562
 Self time:   0.004562

count  total (s)   self (s)
  622              0.004271     return has('win16') || has('win32') || has('win64')

FUNCTION  lightline#statusline()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 307
Called 28 times
Total time:   0.033895
 Self time:   0.000776

count  total (s)   self (s)
   28              0.000087   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
   28              0.000015   endif
   28   0.033711   0.000592   return s:line(0, a:inactive)

FUNCTION  <SNR>146_HandleESLintOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim line 223
Called 6 times
Total time:   0.010438
 Self time:   0.000425

count  total (s)   self (s)
    6   0.009128   0.000067     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
    6              0.000003     endif
                            
    6              0.000015     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
    6              0.000002     endif
                            
    6              0.000007     if a:type is# 'json'
    6   0.000936   0.000100         let l:output = s:parseJSON(a:buffer, a:lines)
                                else
                                    let l:output = s:parseLines(a:buffer, a:lines)
    6              0.000002     endif
                            
    6   0.000194   0.000078     call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
    6              0.000064     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
                                    call s:AddHintsForTypeScriptParsingErrors(l:output)
    6              0.000002     endif
                            
    6              0.000005     return l:output

FUNCTION  <SNR>131_GetVars()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 45
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000014   call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')

FUNCTION  <SNR>75_CursorHoldUpdate()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 263
Called 1 time
Total time:   0.022986
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000002     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
    1              0.000001     endif
                            
    1   0.000048   0.000006     if !g:NERDTree.IsOpen()
                                    return
    1              0.000000     endif
                            
                                " Do not update when a special buffer is selected
    1              0.000002     if !empty(&l:buftype)
                                    return
    1              0.000000     endif
                            
    1              0.000002     let l:winnr = winnr()
    1              0.000002     let l:altwinnr = winnr('#')
                            
    1   0.000157   0.000006     call g:NERDTree.CursorToTreeWin()
    1   0.016042   0.000007     call b:NERDTree.root.refreshFlags()
    1   0.006645   0.000007     call NERDTreeRender()
                            
    1              0.000005     exec l:altwinnr . 'wincmd w'
    1              0.000073     exec l:winnr . 'wincmd w'

FUNCTION  <SNR>52_CountNonESCedOccurances()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2110
Called 8 times
Total time:   0.000434
 Self time:   0.000352

count  total (s)   self (s)
                                "get the index of the first occurrence of searchstr
    8              0.000024     let indx = stridx(a:str, a:searchstr)
                            
                                "if there is an instance of searchstr in str process it
    8              0.000008     if indx !=# -1
                                    "get the remainder of str after this instance of searchstr is removed
    4              0.000009         let lensearchstr = strlen(a:searchstr)
    4              0.000012         let strLeft = strpart(a:str, indx+lensearchstr)
                            
                                    "if this instance of searchstr is not escaped, add one to the count
                                    "and recurse. If it is escaped, just recurse
    4   0.000188   0.000037         if !s:IsEscaped(a:str, indx, a:escChar)
    4              0.000021             return 1 + s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
                                    else
                                        return s:CountNonESCedOccurances(strLeft, a:searchstr, a:escChar)
                                    endif
    4              0.000002     endif

FUNCTION  <SNR>162_is_jsx_region()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 62
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return a:syntax =~? 'jsxRegion'

FUNCTION  <SNR>104_lcm()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow_main.vim line 74
Called 2 times
Total time:   0.000043
 Self time:   0.000015

count  total (s)   self (s)
    2   0.000042   0.000015 	return (a:a / s:gcd(a:a, a:b)) * a:b

FUNCTION  ale#fixers#prettier#ApplyFixForVersion()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/prettier.vim line 37
Called 3 times
Total time:   0.006708
 Self time:   0.000420

count  total (s)   self (s)
    3   0.005915   0.000029     let l:executable = ale#fixers#prettier#GetExecutable(a:buffer)
    3   0.000048   0.000021     let l:options = ale#Var(a:buffer, 'javascript_prettier_options')
    3              0.000003     let l:parser = ''
                            
    3              0.000066     let l:filetypes = split(getbufvar(a:buffer, '&filetype'), '\.')
                            
    3              0.000010     if index(l:filetypes, 'handlebars') > -1
                                    let l:parser = 'glimmer'
    3              0.000002     endif
                            
                                " Append the --parser flag depending on the current filetype (unless it's
                                " already set in g:javascript_prettier_options).
    3              0.000041     if empty(expand('#' . a:buffer . ':e')) && l:parser is# ''  && match(l:options, '--parser') == -1
                                    " Mimic Prettier's defaults. In cases without a file extension or
                                    " filetype (scratch buffer), Prettier needs `parser` set to know how
                                    " to process the buffer.
                                    if ale#semver#GTE(a:version, [1, 16, 0])
                                        let l:parser = 'babel'
                                    else
                                        let l:parser = 'babylon'
                                    endif
                            
                                    let l:prettier_parsers = {    'typescript': 'typescript',    'css': 'css',    'less': 'less',    'scss': 'scss',    'json': 'json',    'json5': 'json5',    'graphql': 'graphql',    'markdown': 'markdown',    'vue': 'vue',    'yaml': 'yaml',    'html': 'html',}
                            
                                    for l:filetype in l:filetypes
                                        if has_key(l:prettier_parsers, l:filetype)
                                            let l:parser = l:prettier_parsers[l:filetype]
                                            break
                                        endif
                                    endfor
    3              0.000002     endif
                            
    3              0.000006     if !empty(l:parser)
                                    let l:options = (!empty(l:options) ? l:options . ' ' : '') . '--parser ' . l:parser
    3              0.000001     endif
                            
                                " Special error handling needed for prettier_d
    3              0.000024     if l:executable =~# 'prettier_d$'
                                    return {   'command': ale#path#BufferCdString(a:buffer)       . ale#Escape(l:executable)       . (!empty(l:options) ? ' ' . l:options : '')       . ' --stdin-filepath %s --stdin',   'process_with': 'ale#fixers#prettier#ProcessPrettierDOutput',}
    3              0.000001     endif
                            
                                " 1.4.0 is the first version with --stdin-filepath
    3   0.000047   0.000029     if ale#semver#GTE(a:version, [1, 4, 0])
    3   0.000421   0.000064         return {   'command': ale#path#BufferCdString(a:buffer)       . ale#Escape(l:executable)       . (!empty(l:options) ? ' ' . l:options : '')       . ' --stdin-filepath %s --stdin',}
                                endif
                            
                                return {   'command': ale#Escape(l:executable)       . ' %t'       . (!empty(l:options) ? ' ' . l:options : '')       . ' --write',   'read_temporary_file': 1,}

FUNCTION  ale#fix#ApplyFixes()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 49
Called 3 times
Total time:  32.493720
 Self time:   0.000703

count  total (s)   self (s)
    3              0.000009     let l:data = g:ale_fix_buffer_data[a:buffer]
    3              0.000005     let l:data.output = a:output
    3              0.000030     let l:data.changes_made = l:data.lines_before !=# l:data.output " no-custom-checks
    3              0.000003     let l:data.done = 1
                            
    3   0.001719   0.000056     call ale#command#RemoveManagedFiles(a:buffer)
                            
    3              0.000007     if !bufexists(a:buffer)
                                    " Remove the buffer data when it doesn't exist.
                                    call remove(g:ale_fix_buffer_data, a:buffer)
    3              0.000001     endif
                            
    3              0.000005     if l:data.changes_made && bufexists(a:buffer)
    2              0.000253         let l:lines = getbufline(a:buffer, 1, '$')
                            
    2              0.000239         if l:data.lines_before != l:lines
                                        call remove(g:ale_fix_buffer_data, a:buffer)
                                        execute 'echoerr ''The file was changed before fixing finished'''
                            
                                        return
    2              0.000001         endif
    3              0.000001     endif
                            
                                " We can only change the lines of a buffer which is currently open,
                                " so try and apply the fixes to the current buffer.
    3  32.491407   0.000054     call ale#fix#ApplyQueuedFixes(a:buffer)

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 31
Called 102 times
Total time:   0.000903
 Self time:   0.000903

count  total (s)   self (s)
  102              0.000509   if empty(s:client) || s:client['running'] == 0
                                return 0
  102              0.000055   endif
  102              0.000082   return 1

FUNCTION  113()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim line 88
Called 16 times
Total time:   0.000561
 Self time:   0.000152

count  total (s)   self (s)
   16   0.000556   0.000147     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 44
Called 12 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   12              0.000086     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  NERDTreeGitStatusRefreshListener()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 61
Called 34 times
Total time:   0.027487
 Self time:   0.001194

count  total (s)   self (s)
   34              0.000155     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
   34              0.000016     endif
   34              0.000050     let l:path = a:event.subject
   34   0.026482   0.000400     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
   34   0.000500   0.000320     call l:path.flagSet.clearFlags('git')
   34              0.000042     if l:flag !=# ''
    2   0.000042   0.000010         call l:path.flagSet.addFlag('git', l:flag)
   34              0.000014     endif

FUNCTION  <SNR>149_FindHistoryItem()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim line 36
Called 18 times
Total time:   0.000820
 Self time:   0.000633

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   90   0.000429   0.000241     for l:obj in reverse(ale#history#Get(a:buffer))
   90              0.000109         if l:obj.job_id == a:job_id
   18              0.000015             return l:obj
   72              0.000041         endif
   72              0.000030     endfor
                            
                                return {}

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 535
Called 9 times
Total time:   0.016434
 Self time:   0.000214

count  total (s)   self (s)
    9              0.000052     let l:Command = has_key(a:linter, 'command_callback')   ? function(a:linter.command_callback)   : a:linter.command
                            
    9   0.016372   0.000152     return type(l:Command) is v:t_func   ? l:Command(a:buffer)   : l:Command

FUNCTION  lightline#mode()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 212
Called 234 times
Total time:   0.001488
 Self time:   0.001488

count  total (s)   self (s)
  234              0.001252   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>51_fzf_restore_colors()
    Defined: ~/.vim/plugged/fzf.vim/plugin/fzf.vim line 90
Called 2 times
Total time:   0.000386
 Self time:   0.000386

count  total (s)   self (s)
    2              0.000024     if exists('#User#FzfStatusLine')
                                  doautocmd User FzfStatusLine
    2              0.000001     else
    2              0.000033       if $TERM !~ "256color"
                                    highlight default fzf1 ctermfg=1 ctermbg=8 guifg=#E12672 guibg=#565656
                                    highlight default fzf2 ctermfg=2 ctermbg=8 guifg=#BCDDBD guibg=#565656
                                    highlight default fzf3 ctermfg=7 ctermbg=8 guifg=#D9D9D9 guibg=#565656
    2              0.000001       else
    2              0.000138         highlight default fzf1 ctermfg=161 ctermbg=238 guifg=#E12672 guibg=#565656
    2              0.000075         highlight default fzf2 ctermfg=151 ctermbg=238 guifg=#BCDDBD guibg=#565656
    2              0.000076         highlight default fzf3 ctermfg=252 ctermbg=238 guifg=#D9D9D9 guibg=#565656
    2              0.000002       endif
    2              0.000022       setlocal statusline=%#fzf1#\ >\ %#fzf2#fz%#fzf3#f
    2              0.000001     endif

FUNCTION  <SNR>96_expand()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 369
Called 56 times
Total time:   0.015770
 Self time:   0.011170

count  total (s)   self (s)
   56              0.000104   let components = []
   56              0.000065   let expanded = []
   56              0.000059   let indices = []
   56              0.000060   let prevtype = ''
   56              0.000065   let previndex = -1
   56   0.007519   0.002919   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
  238              0.000447   for [component, expand, type, index] in xs
  182              0.000271     if prevtype !=# type
  112              0.000590       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
  112              0.000065       endfor
  112              0.000254       call add(indices, type)
  112              0.000207       call add(components, [])
  112              0.000178       call add(expanded, [])
  182              0.000131     endif
  182              0.000426     call extend(components[-1], component)
  182              0.000841     call extend(expanded[-1], repeat([expand], len(component)))
  182              0.000278     let prevtype = type
  182              0.000205     let previndex = index
  238              0.000247   endfor
   56              0.000328   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
   56              0.000059   endfor
   56              0.000248   call add(indices, string(len(a:components)))
   56              0.000114   return [components, expanded, indices]

FUNCTION  ale#util#FunctionArgCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 353
Called 6 times
Total time:   0.001100
 Self time:   0.000245

count  total (s)   self (s)
    6   0.000122   0.000073     let l:Function = ale#util#GetFunction(a:function)
    6   0.000876   0.000069     let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
    6              0.000007     if l:count == 0
                                    let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
                                    if l:function_name =~# '#'
                                        execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
                                        let l:count = s:LoadArgCount(l:Function)
                                    endif
    6              0.000003     endif
                            
    6              0.000006     return l:count

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 471
Called 34 times
Total time:   0.005783
 Self time:   0.005554

count  total (s)   self (s)
   34              0.000038   if a:0 == 0
                                let fileNodeExtension = expand('%:e')
                                let fileNode = expand('%:t')
                                let isDirectory = 0
   34              0.000019   else
   34              0.000119     let fileNodeExtension = fnamemodify(a:1, ':e')
   34              0.000101     let fileNode = fnamemodify(a:1, ':t')
   34              0.000027     if a:0 > 1
   14              0.000016       let isDirectory = a:2
   20              0.000013     else
   20              0.000020       let isDirectory = 0
   34              0.000014     endif
   34              0.000012   endif
                            
   34              0.000051   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
   34              0.000056     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   34              0.000080     let fileNodeExtension = tolower(fileNodeExtension)
   34              0.000069     let fileNode = tolower(fileNode)
                            
  340              0.000792     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
  306              0.001898       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
  306              0.000095       endif
  340              0.000155     endfor
                            
   34              0.000070     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   34              0.000083       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
    6              0.000013         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   28              0.000119       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
   12              0.000029         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
   16              0.000013       elseif isDirectory == 1
   12              0.000020         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   34              0.000015       endif
   34              0.000013     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   34              0.000014   endif
                            
   34   0.000734   0.000505   let artifactFix = s:DevIconsGetArtifactFix()
                            
   34              0.000055   return symbol . artifactFix
                            

FUNCTION  <SNR>96_convert()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 336
Called 182 times
Total time:   0.003217
 Self time:   0.003217

count  total (s)   self (s)
  182              0.000564   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
  182              0.000110   else
  182              0.000582     return [[[a:name], 0, a:index, a:index]]
                              endif

FUNCTION  <SNR>52_Right()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2991
Called 123 times
Total time:   0.001918
 Self time:   0.001828

count  total (s)   self (s)
  123              0.000242     let params = a:0 ? a:1 : {}
                            
  123              0.000451     let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['rightAlt'] : b:NERDCommenterDelims['right']
                            
  123              0.000132     if delim ==# ''
   61              0.000046         return ''
   62              0.000025     endif
                            
   62              0.000114     if has_key(params, 'space') && g:NERDSpaceDelims
                                    let delim = s:spaceStr . delim
   62              0.000025     endif
                            
   62              0.000105     if has_key(params, 'esc')
   21   0.000251   0.000161         let delim = s:Esc(delim)
   62              0.000027     endif
                            
   62              0.000045     return delim

FUNCTION  <SNR>52_AddRightDelim()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1922
Called 20 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
   20              0.000031     if a:delim ==# ''
   20              0.000021         return a:theLine
                                else
                                    return substitute(a:theLine, '$', a:delim, '')
                                endif

FUNCTION  ale#sign#ParsePattern()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 179
Called 6 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    6              0.000006     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " строка=1  id=1000001  группа=ale  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  グループ=ale  名前=ALEWarningSign
                                    " línea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
    6              0.000009         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " строка=1  id=1000001  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  名前=ALEWarningSign
                                    " línea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    6              0.000002     endif
                            
    6              0.000006     return l:pattern

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 78
Called 6 times
Total time:   0.001488
 Self time:   0.001488

count  total (s)   self (s)
    6              0.001484     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  ale#semver#RunWithVersionCheck()
    Defined: ~/.vim/plugged/ale/autoload/ale/semver.vim line 37
Called 6 times
Total time:   0.014963
 Self time:   0.000195

count  total (s)   self (s)
    6              0.000013     if empty(a:executable)
                                    return ''
    6              0.000003     endif
                            
    6              0.000012     let l:cache = s:version_cache
                            
    6              0.000016     if has_key(s:version_cache, a:executable)
    6   0.014903   0.000135         return a:Callback(a:buffer, s:version_cache[a:executable])
                                endif
                            
                                return ale#command#Run(   a:buffer,   a:command,   {_, output -> a:Callback(a:buffer, s:GetVersion(a:executable, output))},   {'output_stream': 'both', 'executable': a:executable})

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 226
Called 24 times
Total time:   0.000773
 Self time:   0.000773

count  total (s)   self (s)
   24              0.000048     let l:min = 0
   24              0.000061     let l:max = len(a:loclist) - 1
                            
   34              0.000041     while 1
   34              0.000046         if l:max < l:min
   24              0.000022             return -1
   10              0.000006         endif
                            
   10              0.000019         let l:mid = (l:min + l:max) / 2
   10              0.000020         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   10              0.000016         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
   10              0.000014         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
   10              0.000013         elseif l:item.lnum < a:line
   10              0.000013             let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
   10              0.000006         endif
   10              0.000007     endwhile

FUNCTION  <SNR>104_eq()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow_main.vim line 60
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000013 	return type(a:x) == type(a:y) && a:x == a:y

FUNCTION  <SNR>158_BuildSignMap()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 281
Called 6 times
Total time:   0.000710
 Self time:   0.000525

count  total (s)   self (s)
    6   0.000094   0.000036     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    6              0.000006     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    6              0.000016     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    6              0.000003     else
    6              0.000009         let l:selected_grouped_items = a:grouped_items
    6              0.000003     endif
                            
    6              0.000006     let l:sign_map = {}
    6              0.000008     let l:sign_offset = g:ale_sign_offset
                            
    9              0.000015     for [l:line, l:sign_id, l:name] in a:current_sign_list
    3              0.000018         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    3              0.000004         if l:sign_id > l:sign_offset
    3              0.000003             let l:sign_offset = l:sign_id
    3              0.000001         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    3              0.000007         call add(l:sign_info.current_id_list, l:sign_id)
    3              0.000006         call add(l:sign_info.current_name_list, l:name)
                            
    3              0.000006         let l:sign_map[l:line] = l:sign_info
    9              0.000013     endfor
                            
    9              0.000012     for l:group in l:selected_grouped_items
    3              0.000004         let l:line = l:group[0].lnum
    3              0.000020         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
    3   0.000168   0.000040         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
    3              0.000004         let l:sign_info.items = l:group
                            
    3              0.000009         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
    3              0.000003         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
    2              0.000004             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    1              0.000001         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000002             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000001             let l:sign_offset += 1
    3              0.000001         endif
                            
    3              0.000006         let l:sign_map[l:line] = l:sign_info
    9              0.000015     endfor
                            
    6              0.000005     return l:sign_map

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 25
Called 3 times
Total time:   0.029246
 Self time:   0.000214

count  total (s)   self (s)
    3   0.000078   0.000030     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    3              0.000003     if l:should_lint
    3              0.000012         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    3              0.000002     endif
                            
    3   0.000100   0.000044     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
    3   0.029004   0.000075         let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
    3              0.000010         let l:should_lint = l:should_lint && !l:will_fix
    3              0.000002     endif
                            
    3              0.000010     if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
    3              0.000002     endif

FUNCTION  ale#fix#InitBufferData()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 331
Called 3 times
Total time:   0.000546
 Self time:   0.000546

count  total (s)   self (s)
                                " The 'done' flag tells the function for applying changes when fixing
                                " is complete.
    3              0.000540     let g:ale_fix_buffer_data[a:buffer] = {   'lines_before': getbufline(a:buffer, 1, '$'),   'done': 0,   'should_save': a:fixing_flag is# 'save_file',   'temporary_directory_list': [],}

FUNCTION  <SNR>159_FixList()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim line 54
Called 6 times
Total time:   0.000431
 Self time:   0.000209

count  total (s)   self (s)
    6   0.000098   0.000037     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    6              0.000007     let l:new_list = []
                            
    9              0.000011     for l:item in a:list
    3              0.000013         let l:fixed_item = copy(l:item)
                            
    3   0.000195   0.000033         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    3              0.000003         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
    3              0.000002         endif
                            
    3              0.000008         call add(l:new_list, l:fixed_item)
    9              0.000012     endfor
                            
    6              0.000005     return l:new_list

FUNCTION  <SNR>31_request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 122
Called 9 times
Total time:   0.076892
 Self time:   0.076725

count  total (s)   self (s)
    9   0.000184   0.000132   let channel = coc#client#get_channel(self)
    9              0.000028   if empty(channel) | return '' | endif
    9              0.000008   try
    9              0.000008     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
    9              0.000005     else
    9   0.076158   0.076042       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
    9              0.000012   endtry

FUNCTION  <SNR>131_sw()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 51
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return shiftwidth()

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 309
Called 6 times
Total time:   0.002533
 Self time:   0.000971

count  total (s)   self (s)
    6              0.000012     let l:bufnr_map = {}
    6              0.000008     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    6   0.001574   0.000085     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    9              0.000015     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    3              0.000039         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    3              0.000003         if a:from_other_source
                                        let l:item.from_other_source = 1
    3              0.000002         endif
                            
    3              0.000005         if has_key(l:old_item, 'code')
    3              0.000006             let l:item.code = l:old_item.code
    3              0.000001         endif
                            
    3              0.000009         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
    3              0.000006         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
    3              0.000001         endif
                            
    3              0.000005         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
    3              0.000001         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    3              0.000005         if has_key(l:old_item, 'end_col')
    3              0.000007             let l:item.end_col = str2nr(l:old_item.end_col)
    3              0.000001         endif
                            
    3              0.000005         if has_key(l:old_item, 'end_lnum')
    3              0.000007             let l:item.end_lnum = str2nr(l:old_item.end_lnum)
    3              0.000001         endif
                            
    3              0.000004         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
    3              0.000001         endif
                            
    3              0.000003         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
    3              0.000006         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
    3              0.000005         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
    3              0.000001         endif
                            
    3              0.000007         call add(l:new_loclist, l:item)
    9              0.000049     endfor
                            
    6   0.000141   0.000067     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    6              0.000010     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    6              0.000003     endif
                            
    6              0.000005     return l:new_loclist

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 123
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000005     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
    3              0.000001     endif
                            
    3              0.000003     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
    3              0.000001     endif
                            
    3              0.000007     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
    3              0.000001     endif
                            
    3              0.000003     return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 668
Called 9 times
Total time:   0.178492
 Self time:   0.003026

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    9   0.000180   0.000090     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    9   0.000921   0.000143     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    9   0.000674   0.000221     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    9   0.000181   0.000093     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    9   0.000380   0.000343     silent doautocmd <nomodeline> User ALELintPre
                            
   90              0.000210     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   81              0.000139         if !l:linter.lint_file || a:should_lint_file
   81   0.175054   0.001034             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
    9              0.000022                 let l:can_clear_results = 0
   81              0.000048             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
   81              0.000040         endif
   90              0.000081     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    9              0.000010     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    9              0.000009     elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
    9              0.000004     endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 180
Called 249 times
Total time:   0.000929
 Self time:   0.000929

count  total (s)   self (s)
  249              0.000819     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>169_ag_to_qf()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 660
Called 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000046   let parts = split(a:line, '[^:]\zs:\ze[^:]')
    1              0.000009   let text = join(parts[(a:has_column ? 3 : 2):], ':')
    1              0.000010   let dict = {'filename': &acd ? fnamemodify(parts[0], ':p') : parts[0], 'lnum': parts[1], 'text': text}
    1              0.000001   if a:has_column
    1              0.000002     let dict.col = parts[2]
    1              0.000001   endif
    1              0.000001   return dict

FUNCTION  ale#path#FindNearestDirectory()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim line 44
Called 9 times
Total time:   0.003649
 Self time:   0.003649

count  total (s)   self (s)
    9              0.000536     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
    9              0.000049     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
    9              0.002759     let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
    9              0.000031     if !empty(l:relative_path)
    9              0.000252         return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''

FUNCTION  46()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 851
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000045     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  <SNR>164_HandleExit()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 78
Called 6 times
Total time:  32.525430
 Self time:   0.008515

count  total (s)   self (s)
    6              0.000033     let l:buffer_info = get(g:ale_fix_buffer_data, a:buffer, {})
                            
    6              0.000009     if empty(l:buffer_info)
                                    return
    6              0.000002     endif
                            
    6              0.000006     if a:job_info.read_temporary_file
                                    let l:output = !empty(a:data.temporary_file)   ?  readfile(a:data.temporary_file)   : []
    6              0.000003     else
    6              0.000008         let l:output = a:job_output
    6              0.000002     endif
                            
    6              0.000017     let l:ChainCallback = get(a:job_info, 'chain_with', v:null)
    6              0.000014     let l:ProcessWith = get(a:job_info, 'process_with', v:null)
                            
                                " Post-process the output with a function if we have one.
    6              0.000008     if l:ProcessWith isnot v:null
    3   0.000541   0.000051         let l:output = call(l:ProcessWith, [a:buffer, l:output])
    6              0.000003     endif
                            
                                " Use the output of the job for changing the file if it isn't empty,
                                " otherwise skip this job and use the input from before.
                                "
                                " We'll use the input from before for chained commands.
    6              0.007986     if l:ChainCallback is v:null && !empty(split(join(l:output)))
    3              0.000013         let l:input = l:output
    3              0.000002     else
    3              0.000005         let l:input = a:job_info.input
    6              0.000003     endif
                            
    6              0.000016     if l:ChainCallback isnot v:null && !get(g:, 'ale_ignore_2_4_warnings')
                                    execute 'echom ''chain_with is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
    6              0.000003     endif
                            
    6              0.000022     let l:next_index = l:ChainCallback is v:null   ? a:job_info.callback_index + 1   : a:job_info.callback_index
                            
    6  32.516626   0.000202     call s:RunFixer({   'buffer': a:buffer,   'input': l:input,   'output': l:output,   'callback_list': a:job_info.callback_list,   'callback_index': l:next_index,   'chain_callback': l:ChainCallback,})

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp_linter.vim line 184
Called 18 times
Total time:   0.014437
 Self time:   0.000983

count  total (s)   self (s)
   18              0.000072     let l:buffer_ale_root = getbufvar(a:buffer, 'ale_lsp_root', {})
                            
   18              0.000042     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
   18              0.000010     endif
                            
                                " Try to get a buffer-local setting for the root
   18              0.000042     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
   18              0.000006     endif
                            
                                " Try to get a global setting for the root
   18              0.000051     if has_key(g:ale_lsp_root, a:linter.name)
                                    let l:Root = g:ale_lsp_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
   18              0.000006     endif
                            
                                " Fall back to the linter-specific configuration
   18              0.000031     if has_key(a:linter, 'project_root')
   18              0.000050         let l:Root = a:linter.project_root
                            
   18   0.013807   0.000352         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 466
Called 24 times
Total time:   0.001579
 Self time:   0.000806

count  total (s)   self (s)
   24              0.000138     let l:info = get(g:ale_buffer_info, a:buffer, {})
   24              0.000082     let l:loclist = get(l:info, 'loclist', [])
   24              0.000076     let l:pos = getpos('.')
   24   0.001123   0.000350     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
   24              0.000060     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
   24              0.000042     return [l:info, l:loc]

FUNCTION  <SNR>134_GetLinterNames()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 439
Called 12 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
   12              0.000053     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   12              0.000040     if l:buffer_ale_linters is# 'all'
                                    return 'all'
   12              0.000007     endif
                            
                                " b:ale_linters can be set to a List.
   12              0.000027     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
   12              0.000005     endif
                            
                                " Try to get a buffer-local setting for the filetype
   12              0.000029     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
   12              0.000005     endif
                            
                                " Try to get a global setting for the filetype
   12              0.000028     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
   12              0.000005     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
   12              0.000013     if g:ale_linters_explicit
                                    return []
   12              0.000005     endif
                            
                                " Try to get a default setting for the filetype
   12              0.000053     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
   12              0.000005     endif
                            
   12              0.000010     return 'all'

FUNCTION  <SNR>52_IsEscaped()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2658
Called 4 times
Total time:   0.000152
 Self time:   0.000139

count  total (s)   self (s)
                                "initialise numEscChars to 0 and look at the char before indx
    4              0.000005     let numEscChars = 0
    4              0.000005     let curIndx = a:indx-1
                            
                                "keep going back thru str until we either reach the start of the str or
                                "run out of esc chars
    4              0.000015     while curIndx >= 0 && strpart(a:str, curIndx, 1) ==# a:escChar
                            
                                    "we have found another esc char so add one to the count and move left
                                    "one char
                                    let numEscChars  = numEscChars + 1
                                    let curIndx = curIndx - 1
                            
    4              0.000007     endwhile
                            
                                "if there is an odd num of esc chars directly before the char at indx then
                                "the char at indx is escaped
    4   0.000089   0.000076     return !s:IsNumEven(numEscChars)

FUNCTION  <SNR>145_ExitCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 211
Called 15 times
Total time:  32.554191
 Self time:   0.001079

count  total (s)   self (s)
   15              0.000044     if !has_key(s:buffer_data, a:buffer)
                                    return
   15              0.000006     endif
                            
   15              0.000030     let l:jobs = s:buffer_data[a:buffer].jobs
                            
   15              0.000027     if !has_key(l:jobs, a:data.job_id)
    3              0.000002         return
   12              0.000004     endif
                            
   12              0.000036     let l:job_type = remove(l:jobs, a:data.job_id)
                            
   12              0.000012     if g:ale_history_enabled
   12   0.000866   0.000110         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
   12              0.000025         if g:ale_history_log_output && a:data.log_output is 1
    6   0.000474   0.000136             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
   12              0.000007         endif
   12              0.000005     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
   12              0.000093     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
   12  32.552309   0.000292     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
   12              0.000032     let l:result = a:data.result
   12              0.000021     let l:result.value = l:value
                            
   12              0.000037     if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
   12              0.000006     endif

FUNCTION  ale#history#Add()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim line 12
Called 69 times
Total time:   0.003424
 Self time:   0.003424

count  total (s)   self (s)
   69              0.000133     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
   69              0.000055     endif
                            
   69              0.000272     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   69              0.000189     if len(l:history) >= g:ale_max_buffer_history_size
   69              0.000643         let l:history = l:history[1:]
   69              0.000057     endif
                            
   69              0.000376     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   69              0.001076     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>145_TemporaryFilename()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 116
Called 15 times
Total time:   0.000719
 Self time:   0.000411

count  total (s)   self (s)
   15              0.000064     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   15              0.000024     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
   15              0.000007     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   15   0.000521   0.000213     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>95_Lint()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 99
Called 12 times
Total time:   0.192431
 Self time:   0.002477

count  total (s)   self (s)
                                " Use the filetype from the buffer
   12              0.000150     let l:filetype = getbufvar(a:buffer, '&filetype')
   12   0.011365   0.000238     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
   12   0.000327   0.000143     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
   12   0.000203   0.000084     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
   12              0.000086     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
   12              0.000071     let g:ale_want_results_buffer = a:buffer
   12   0.001046   0.001014     silent doautocmd <nomodeline> User ALEWantResults
   12              0.000049     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   12              0.000067     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
    3              0.000003         return
    9              0.000005     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    9              0.000270     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    9   0.178660   0.000168     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  <SNR>27_LoadIndent()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent.vim line 13
Called 2 times
Total time:   0.000792
 Self time:   0.000792

count  total (s)   self (s)
    2              0.000010     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    2              0.000001     endif
    2              0.000010     let s = expand("<amatch>")
    2              0.000004     if s != ""
    2              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000016       for name in split(s, '\.')
    2              0.000721 	exe 'runtime! indent/' . name . '.vim'
    4              0.000005       endfor
    2              0.000001     endif

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 167
Called 13 times
Total time:   0.000570
 Self time:   0.000570

count  total (s)   self (s)
   13              0.000031     let old_ei = &eventignore
   13              0.000011     if a:ignoreAll
   13              0.000071         set eventignore=all
   13              0.000007     endif
   13              0.000007     try
   13              0.000346         exec a:cmd
   13              0.000015     finally
   13              0.000048         let &eventignore = old_ei
   13              0.000010     endtry

FUNCTION  <SNR>131_Token()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 165
Called 1 time
Total time:   0.000041
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000041   0.000034   return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()

FUNCTION  ale_linters#javascript#flow_ls#FindProjectRoot()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/flow_ls.vim line 9
Called 9 times
Total time:   0.007023
 Self time:   0.000197

count  total (s)   self (s)
    9   0.006964   0.000138     let l:flow_config = ale#path#FindNearestFile(a:buffer, '.flowconfig')
                            
    9              0.000016     if !empty(l:flow_config)
                                    return fnamemodify(l:flow_config, ':h')
    9              0.000004     endif
                            
    9              0.000005     return ''

FUNCTION  ale#engine#Cleanup()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 707
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
    2              0.000012     if get(v:, 'exiting', v:null) isnot v:null
                                    return
    2              0.000001     endif
                            
    2              0.000007     if exists('*ale#lsp#CloseDocument')
                                    call ale#lsp#CloseDocument(a:buffer)
    2              0.000001     endif
                            
    2              0.000011     if !has_key(g:ale_buffer_info, a:buffer)
    2              0.000002         return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>169_open()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 247
Called 1 time
Total time:   0.000330
 Self time:   0.000323

count  total (s)   self (s)
    1              0.000132   if stridx('edit', a:cmd) == 0 && fnamemodify(a:target, ':p') ==# expand('%:p')
                                return
    1              0.000001   endif
                              execute a:cmd s:escape(a:target)

FUNCTION  <SNR>164_AddSubCallbacks()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 247
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000010     if type(a:callbacks) is v:t_string
                                    call add(a:full_list, a:callbacks)
    3              0.000006     elseif type(a:callbacks) is v:t_list
    3              0.000009         call extend(a:full_list, a:callbacks)
                                else
                                    return 0
    3              0.000002     endif
                            
    3              0.000002     return 1

FUNCTION  <SNR>52_FindBoundingLinesOfSexyCom()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2235
Called 21 times
Total time:   0.007617
 Self time:   0.002662

count  total (s)   self (s)
                            
                                "find which delimiters to look for as the start/end delimiters of the comment
   21              0.000029     let left = ''
   21              0.000020     let right = ''
   21   0.000711   0.000200     if s:Multipart()
                                    let left = s:Left({'esc': 1})
                                    let right = s:Right({'esc': 1})
   21   0.000308   0.000250     elseif s:AltMultipart()
   21   0.000884   0.000243         let left = s:Left({'alt': 1, 'esc': 1})
   21   0.000795   0.000202         let right = s:Right({'alt': 1, 'esc': 1})
                                else
                                    return []
   21              0.000009     endif
                            
   21   0.003454   0.000301     let sexyComMarker = s:GetSexyComMarker(0, 1)
                            
                                "initialise the top/bottom line numbers of the sexy comment to -1
   21              0.000025     let top = -1
   21              0.000021     let bottom = -1
                            
   21              0.000033     let currentLine = a:lineNum
   21              0.000058     while top ==# -1 || bottom ==# -1
   21              0.000057         let theLine = getline(currentLine)
                            
                                    "check if the current line is the top of the sexy comment
   21              0.000252         if currentLine <= a:lineNum && theLine =~# '^[ \t]*' . left && theLine !~# '.*' . right && currentLine < s:NumLinesInBuf()
                                        let top = currentLine
                                        let currentLine = a:lineNum
                            
                                    "check if the current line is the bottom of the sexy comment
   21              0.000145         elseif theLine =~# '^[ \t]*' . right && theLine !~# '.*' . left && currentLine > 1
                                        let bottom = currentLine
                            
                                    "the right delimiter is on the same line as the last sexyComMarker
   21              0.000137         elseif theLine =~# '^[ \t]*' . sexyComMarker . '.*' . right
                                        let bottom = currentLine
                            
                                    "we have not found the top or bottom line so we assume currentLine is an
                                    "intermediate line and look to prove otherwise
   21              0.000013         else
                            
                                        "if the line doesn't start with a sexyComMarker then it is not a sexy
                                        "comment
   21              0.000100             if theLine !~# '^[ \t]*' . sexyComMarker
   21              0.000027                 return []
                                        endif
                            
                                    endif
                            
                                    "if top is -1 then we haven't found the top yet so keep looking up
                                    if top ==# -1
                                        let currentLine = currentLine - 1
                                    "if we have found the top line then go down looking for the bottom
                                    else
                                        let currentLine = currentLine + 1
                                    endif
                            
                                endwhile
                            
                                return [top, bottom]

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 441
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000020     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    3              0.000011     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    3              0.000002     return l:timer_id

FUNCTION  <SNR>162_is_opening_tag()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 52
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return a:syntax =~? 'jsxOpenPunct'

FUNCTION  ale#command#InitData()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 19
Called 30 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
   30              0.000104     if !has_key(s:buffer_data, a:buffer)
    9              0.000057         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
   30              0.000019     endif

FUNCTION  <SNR>152_StartIfExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp_linter.vim line 327
Called 9 times
Total time:   0.001329
 Self time:   0.000276

count  total (s)   self (s)
    9   0.000168   0.000126     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
    9              0.000005     endif
                            
    9   0.001096   0.000085     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
    9              0.000006         return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  <SNR>154_StopCursorTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim line 55
Called 30 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   30              0.000049     if s:cursor_timer != -1
   24              0.000072         call timer_stop(s:cursor_timer)
   24              0.000039         let s:cursor_timer = -1
   30              0.000017     endif

FUNCTION  <SNR>131_PreviousToken()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 169
Called 1 time
Total time:   0.000091
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000005   let [l:pos, tok] = [getpos('.'), '']
    1              0.000010   if search('\m\k\{1,}\|\S','ebW')
    1              0.000004     if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
    1              0.000000     else
    1              0.000006       let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
    1              0.000001       if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
    1              0.000000       else
    1   0.000048   0.000007         let tok = s:Token()
    1              0.000001       endif
    1              0.000000     endif
    1              0.000000   endif
    1              0.000001   return tok

FUNCTION  <SNR>162_start_col()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 31
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000015   return len(matchstr(getline(a:lnum), '^\s*')) + 1

FUNCTION  <SNR>49_validate_layout()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 279
Called 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    4              0.000017   for key in keys(a:layout)
    2              0.000009     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
    2              0.000001     endif
    4              0.000004   endfor
    2              0.000002   return a:layout

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim line 49
Called 12 times
Total time:   0.000756
 Self time:   0.000200

count  total (s)   self (s)
   12   0.000680   0.000124     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
   12              0.000027     let l:obj.exit_code = a:exit_code
   12              0.000017     let l:obj.status = 'finished'

FUNCTION  <SNR>169_merge_opts()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 69
Called 4 times
Total time:   0.000153
 Self time:   0.000037

count  total (s)   self (s)
    4   0.000151   0.000035   return s:extend_opts(a:dict, a:eopts, 0)

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 48
Called 5 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    5              0.000007     if a:line >= a:end_line
                                    " For single lines, just return the one position.
    5              0.000016         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  <SNR>96_subseparator()
    Defined: ~/.vim/plugged/lightline.vim/autoload/lightline.vim line 294
Called 70 times
Total time:   0.003528
 Self time:   0.003528

count  total (s)   self (s)
   70              0.000498   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
   70              0.002170   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
   70              0.000786   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  <SNR>159_ShouldOpen()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim line 34
Called 12 times
Total time:   0.000227
 Self time:   0.000128

count  total (s)   self (s)
   12   0.000166   0.000067     let l:val = ale#Var(a:buffer, 'open_list')
   12              0.000029     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   12              0.000021     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 34
Called 15 times
Total time:   0.000380
 Self time:   0.000241

count  total (s)   self (s)
   15   0.000313   0.000173     call ale#command#InitData(a:buffer)
   15              0.000058     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  <SNR>52_LeftMostIndx()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2835
Called 1 time
Total time:   0.001368
 Self time:   0.001107

count  total (s)   self (s)
                            
                                " declare the left most index as an extreme value
    1              0.000002     let leftMostIndx = 1000
                            
                                " go thru the block line by line updating leftMostIndx
    1              0.000002     let currentLine = a:topline
   21              0.000026     while currentLine <= a:bottomline
                            
                                    " get the next line and if it is allowed to be commented, or is not
                                    " commented, check it
   20              0.000045         let theLine = getline(currentLine)
   20              0.000116         if a:countEmptyLines || theLine !~# '^[ \t]*$'
   20              0.000149             if a:countCommentedLines || (!s:IsCommented(s:Left(), s:Right(), theLine) && !s:IsCommented(s:Left({'alt': 1}), s:Right({'alt': 1}), theLine))
                                            " convert spaces to tabs and get the number of leading spaces for
                                            " this line and update leftMostIndx if need be
   20   0.000548   0.000287                 let theLine = s:ConvertLeadingTabsToSpaces(theLine)
   20              0.000270                 let leadSpaceOfLine = strlen( substitute(theLine, '\(^[ \t]*\).*$','\1','') )
   20              0.000029                 if leadSpaceOfLine < leftMostIndx
    1              0.000002                     let leftMostIndx = leadSpaceOfLine
   20              0.000011                 endif
   20              0.000009             endif
   20              0.000012         endif
                            
                                    " move on to the next line
   20              0.000026         let currentLine = currentLine + 1
   21              0.000014     endwhile
                            
    1              0.000001     if leftMostIndx ==# 1000
                                    return 0
    1              0.000001     else
    1              0.000001         return leftMostIndx
                                endif

FUNCTION  142()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim line 141
Called 8 times
Total time:   0.000343
 Self time:   0.000046

count  total (s)   self (s)
    8   0.000332   0.000035     if !self.isCascadable()
    8              0.000007         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  fzf#wrap()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 295
Called 2 times
Total time:   0.001240
 Self time:   0.000437

count  total (s)   self (s)
    2              0.000005   let args = ['', {}, 0]
    2              0.000017   let expects = map(copy(args), 'type(v:val)')
    2              0.000002   let tidx = 0
    8              0.000014   for arg in copy(a:000)
    6              0.000020     let tidx = index(expects, type(arg), tidx)
    6              0.000006     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
    6              0.000003     endif
    6              0.000010     let args[tidx] = arg
    6              0.000006     let tidx += 1
    6              0.000006     unlet arg
    8              0.000007   endfor
    2              0.000005   let [name, opts, bang] = args
                            
    2              0.000004   if len(name)
    2              0.000004     let opts.name = name
    2              0.000001   end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    2              0.000002   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
    2   0.000089   0.000020   elseif !s:has_any(opts, s:layout_keys)
    2              0.000009     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
    2              0.000001     else
    2   0.000169   0.000087       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout)))
    2              0.000001     endif
    2              0.000001   endif
                            
                              " Colors: g:fzf_colors
    2   0.000659   0.000044   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
    2              0.000010   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
    2              0.000001   endif
                            
                              " Action: g:fzf_action
    2   0.000054   0.000017   if !s:has_any(opts, ['sink', 'sink*'])
    2              0.000009     let opts._action = get(g:, 'fzf_action', s:default_action)
    2              0.000018     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    2              0.000004     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    2              0.000008     let opts['sink*'] = remove(opts, 'sink')
    2              0.000001   endif
                            
    2              0.000002   return opts

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 380
Called 12 times
Total time:   0.007128
 Self time:   0.006887

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
   12   0.000375   0.000134     if ale#util#InSandbox()
                                    return []
   12              0.000006     endif
                            
   12              0.000026     let l:combined_linters = []
                            
   24              0.000043     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   12              0.000042         if !has_key(s:runtime_loaded_map, l:filetype)
    1              0.006224             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
    1              0.000011             let s:runtime_loaded_map[l:filetype] = 1
   12              0.000008         endif
                            
   12              0.000109         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   24              0.000035     endfor
                            
   12              0.000015     return l:combined_linters

FUNCTION  <SNR>144_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 561
Called 9 times
Total time:   0.000453
 Self time:   0.000453

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    9              0.000021     let l:name_map = {}
                            
   90              0.000078     for l:linter in a:linters
   81              0.000158         let l:name_map[l:linter.name] = 1
   90              0.000047     endfor
                            
    9              0.000093     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#Pad()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 208
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000012     return !empty(a:string) ? ' ' . a:string : ''

FUNCTION  <SNR>49_fzf_call()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 73
Called 37 times
Total time:   0.000574
 Self time:   0.000574

count  total (s)   self (s)
   37              0.000559     return call(a:fn, a:000)

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 429
Called 12 times
Total time:   0.001051
 Self time:   0.000391

count  total (s)   self (s)
   12   0.000980   0.000321     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   12              0.000032     if type(l:filetype) isnot v:t_list
   12              0.000019         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  209()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim line 7
Called 36 times
Total time:   0.000610
 Self time:   0.000408

count  total (s)   self (s)
   36   0.000391   0.000189     let flags = self._flagsForScope(a:scope)
   36              0.000078     if index(flags, a:flag) == -1
   36              0.000092         call add(flags, a:flag)
   36              0.000019     end

FUNCTION  <SNR>133_ApplyPartialTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 428
Called 3 times
Total time:   0.001156
 Self time:   0.000121

count  total (s)   self (s)
    3              0.000013     if has_key(s:partial_timers, a:timer_id)
    3              0.000025         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    3   0.001113   0.000078         call call(l:Callback, [a:timer_id] + l:args)
    3              0.000001     endif

FUNCTION  ale_linters#javascript#flow#GetExecutable()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/flow.vim line 10
Called 9 times
Total time:   0.008464
 Self time:   0.000199

count  total (s)   self (s)
    9   0.008395   0.000131     let l:flow_config = ale#path#FindNearestFile(a:buffer, '.flowconfig')
                            
    9              0.000024     if empty(l:flow_config)
                                    " Don't run Flow if we can't find a .flowconfig file.
    9              0.000008         return ''
                                endif
                            
                                " Don't run Flow with a configuration file from the home directory by
                                " default, which can eat all of your RAM.
                                if fnamemodify(l:flow_config, ':h') is? $HOME&& !ale#Var(a:buffer, 'javascript_flow_use_home_config')
                                    return ''
                                endif
                            
                                return ale#node#FindExecutable(a:buffer, 'javascript_flow', [   'node_modules/.bin/flow',])

FUNCTION  <SNR>169_ansi()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 197
Called 1 time
Total time:   0.000228
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000092   0.000013   let fg = s:get_color('fg', a:group)
    1   0.000097   0.000033   let bg = s:get_color('bg', a:group)
    1   0.000030   0.000015   let color = (empty(fg) ? s:ansi[a:default] : s:csi(fg, 1)) . (empty(bg) ? '' : ';'.s:csi(bg, 0))
    1              0.000007   return printf("\x1b[%s%sm%s\x1b[m", color, a:0 ? ';1' : '', a:str)

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim line 183
Called 6 times
Total time:   0.001401
 Self time:   0.000134

count  total (s)   self (s)
    6              0.000024     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    3   0.001261   0.000031         call s:SetListsImpl(-1, a:buffer, a:loclist)
    3              0.000001     else
    3   0.000078   0.000041         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    6              0.000002     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 284
Called 70 times
Total time:   0.001232
 Self time:   0.001016

count  total (s)   self (s)
   70              0.000085     try
   70   0.000710   0.000493         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
   70              0.000058     endtry
                            
   70              0.000049     return 0

FUNCTION  210()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim line 15
Called 68 times
Total time:   0.000339
 Self time:   0.000339

count  total (s)   self (s)
   68              0.000295     let self._flags[a:scope] = []

FUNCTION  211()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim line 20
Called 70 times
Total time:   0.000415
 Self time:   0.000415

count  total (s)   self (s)
   70              0.000168     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
   70              0.000033     endif
   70              0.000110     return self._flags[a:scope]

FUNCTION  212()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim line 28
Called 3 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000029     let newObj = copy(self)
    3              0.000005     let newObj._flags = {}
    3              0.000003     return newObj

FUNCTION  214()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim line 45
Called 24 times
Total time:   0.000492
 Self time:   0.000492

count  total (s)   self (s)
   24              0.000025     let flagstring = ''
   72              0.000094     for i in values(self._flags)
   48              0.000160         let flagstring .= join(i)
   72              0.000041     endfor
                            
   24              0.000039     if len(flagstring) == 0
                                    return ''
   24              0.000009     endif
                            
   24              0.000038     return '[' . flagstring . ']'

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim line 15
Called 51 times
Total time:   0.000952
 Self time:   0.000952

count  total (s)   self (s)
   51              0.000100     if has('unix')
   51              0.000387         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
   51              0.000397         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim line 1
Called 37 times
Total time:   0.007880
 Self time:   0.002470

count  total (s)   self (s)
   37              0.000118   let line = getline(".")
   37              0.000072   let col = col('.')
   37              0.000400   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
   32              0.000081     let col = indent('.') + 1
   37              0.000019   endif
   37   0.005896   0.000486   let syn_start = s:syn_name(line('.'), col)
   37              0.000117   let save_cursor = getcurpos()
                            
   37              0.000210   if syn_start =~? '^jsx'
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_start =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
   37              0.000018   else
   37              0.000262     let &l:commentstring = a:original
   37              0.000019   endif
                            
                              " Restore the cursor position
   37              0.000127   call setpos('.', save_cursor)

FUNCTION  ale#path#Upwards()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim line 167
Called 3 times
Total time:   0.000569
 Self time:   0.000510

count  total (s)   self (s)
    3              0.000019     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
    3              0.000011     let l:sep = has('win32') ? '\' : '/'
    3   0.000122   0.000063     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
    3              0.000005     let l:path_list = []
                            
   30              0.000046     while !empty(l:parts)
   27              0.000141         call add(l:path_list, join(l:parts, l:sep))
   27              0.000097         let l:parts = l:parts[:-2]
   30              0.000020     endwhile
                            
    3              0.000011     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
    3              0.000008     elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
    3              0.000042         call map(l:path_list, '''/'' . v:val')
    3              0.000006         call add(l:path_list, '/')
    3              0.000002     endif
                            
    3              0.000003     return l:path_list

FUNCTION  <SNR>169_wrap()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 133
Called 2 times
Total time:   0.001347
 Self time:   0.000107

count  total (s)   self (s)
                              " fzf#wrap does not append --expect if sink or sink* is found
    2              0.000007   let opts = copy(a:opts)
    2              0.000002   let options = ''
    2              0.000004   if has_key(opts, 'options')
    2              0.000017     let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
    2              0.000001   endif
    2              0.000014   if options !~ '--expect' && has_key(opts, 'sink*')
    2              0.000007     let Sink = remove(opts, 'sink*')
    2   0.001266   0.000026     let wrapped = fzf#wrap(a:name, opts, a:bang)
    2              0.000010     let wrapped['sink*'] = Sink
                              else
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
    2              0.000001   endif
    2              0.000002   return wrapped

FUNCTION  ale#node#FindExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/node.vim line 10
Called 84 times
Total time:   0.117947
 Self time:   0.006243

count  total (s)   self (s)
   84   0.002210   0.000948     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
   84              0.000048     endif
                            
  216              0.000368     for l:path in a:path_list
  156   0.111969   0.002373         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
  156              0.000333         if !empty(l:executable)
   24              0.000030             return l:executable
  132              0.000071         endif
  192              0.000189     endfor
                            
   60   0.001747   0.000900     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  NERDTreeGitStatusRefresh()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 75
Called 1 time
Total time:   0.014807
 Self time:   0.000386

count  total (s)   self (s)
    1              0.000005     let b:NERDTreeCachedGitFileStatus = {}
    1              0.000007     let b:NERDTreeCachedGitDirtyDir   = {}
    1              0.000001     let b:NOT_A_GIT_REPOSITORY        = 1
                            
    1   0.000167   0.000037     let l:root = fnamemodify(b:NERDTree.root.path.str(), ':p:gs?\\?/?:S')
    1              0.000004     let l:gitcmd = 'git -c color.status=false -C ' . l:root . ' status -s'
    1              0.000001     if g:NERDTreeShowIgnoredStatus
                                    let l:gitcmd = l:gitcmd . ' --ignored'
    1              0.000000     endif
    1              0.000003     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
    1              0.000000     endif
    1   0.014116   0.000028     let l:statusesStr = system(l:gitcmd)
    1              0.000027     let l:statusesSplit = split(l:statusesStr, '\n')
    1              0.000016     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
    1              0.000001     endif
    1              0.000004     let b:NOT_A_GIT_REPOSITORY = 0
                            
    3              0.000005     for l:statusLine in l:statusesSplit
                                    " cache git status of files
    2              0.000022         let l:pathStr = substitute(l:statusLine, '...', '', '')
    2              0.000011         let l:pathSplit = split(l:pathStr, ' -> ')
    2              0.000005         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
    2              0.000001         else
    2              0.000004             let l:pathStr = l:pathSplit[0]
    2              0.000001         endif
    2   0.000063   0.000037         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
    2              0.000009         if l:pathStr =~# '\.\./.*'
                                        continue
    2              0.000001         endif
    2   0.000041   0.000029         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
    2              0.000011         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
    2              0.000003         if l:statusKey == 'Ignored'
                                        if isdirectory(l:pathStr)
                                            let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
                                        endif
    2              0.000001         else
    2   0.000207   0.000041             call s:NERDTreeCacheDirtyDir(l:pathStr)
    2              0.000001         endif
    3              0.000004     endfor

FUNCTION  <SNR>49_defaults()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 273
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000009   let rules = copy(get(g:, 'fzf_colors', {}))
    2              0.000019   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    2              0.000008   return empty(colors) ? '' : fzf#shellescape('--color='.colors)

FUNCTION  230()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 177
Called 9 times
Total time:   0.000418
 Self time:   0.000089

count  total (s)   self (s)
    9   0.000394   0.000065     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
    9              0.000005     endif

FUNCTION  220()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 99
Called 9 times
Total time:   0.001347
 Self time:   0.000182

count  total (s)   self (s)
    9   0.000459   0.000041     call g:NERDTree.MustBeOpen()
    9   0.000875   0.000128     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', 1)

FUNCTION  226()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 146
Called 27 times
Total time:   0.000861
 Self time:   0.000861

count  total (s)   self (s)
   27              0.000095     if exists('t:NERDTreeBufName')
   27              0.000736         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  227()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 162
Called 18 times
Total time:   0.000788
 Self time:   0.000154

count  total (s)   self (s)
   18   0.000774   0.000140     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  <SNR>105_resolve_parenthesis_with()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 13
Called 8 times
Total time:   0.001539
 Self time:   0.001539

count  total (s)   self (s)
    8              0.000035 	let [paren, contained, containedin, contains_prefix, contains, op] = a:init_state
    8              0.000057 	let p = (type(a:p) == type([])) ? ((len(a:p) == 3) ? printf('start=#%s# step=%s end=#%s#', a:p[0], op, a:p[-1]) : printf('start=#%s# end=#%s#', a:p[0], a:p[-1])) : a:p "NOTE: preprocess the old style parentheses config
                            
    8              0.000374 	let ls = split(p, '\v%(%(start|step|end)\=(.)%(\1@!.)*\1[^ ]*|\w+%(\=[^ ]*)?) ?\zs', 0)
   26              0.000030 	for s in ls
   18              0.000476 		let [k, v] = [matchstr(s, '^[^=]\+\ze\(=\|$\)'), matchstr(s, '^[^=]\+=\zs.*')]
   18              0.000032 		if k == 'step'
                            			let op = s:trim(v)
   18              0.000023 		elseif k == 'contains_prefix'
                            			let contains_prefix = s:trim(v)
   18              0.000019 		elseif k == 'contains'
                            			let contains = s:concat([contains, s:trim(v)])
   18              0.000019 		elseif k == 'containedin'
                            			let containedin = s:concat([containedin, s:trim(v)])
   18              0.000021 		elseif k == 'contained'
                            			let contained = 1
   18              0.000010 		else
   18              0.000035 			let paren .= s
   18              0.000009 		endif
   26              0.000028 	endfor
    8              0.000039 	let rst = [paren, contained, containedin, contains_prefix, contains, op]
                            	"echom json_encode(rst)
    8              0.000008 	return rst

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 205
Called 6 times
Total time:   0.001339
 Self time:   0.000326

count  total (s)   self (s)
    6              0.000042     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    6              0.000057     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
    6   0.000089   0.000036     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
    6              0.000008     if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    6              0.000002     endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    6   0.001109   0.000149     call ale#highlight#UpdateHighlights()

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 299
Called 2 times
Total time:   0.000374
 Self time:   0.000237

count  total (s)   self (s)
    2              0.000033   if !bufloaded(a:bufnr) | return v:null | endif
    2              0.000007   let bufname = bufname(a:bufnr)
    2   0.000331   0.000193   return { 'bufname': bufname, 'size': getfsize(bufname), 'eol': getbufvar(a:bufnr, '&eol'), 'variables': s:variables(a:bufnr), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), 'buftype': getbufvar(a:bufnr, '&buftype'), 'filetype': getbufvar(a:bufnr, '&filetype'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'),}

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 234
Called 6 times
Total time:   0.011669
 Self time:   0.001003

count  total (s)   self (s)
    6   0.000108   0.000052     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    6              0.000007     if g:ale_set_signs
    6   0.003497   0.000100         call ale#sign#SetSigns(a:buffer, a:loclist)
    6              0.000003     endif
                            
    6              0.000008     if g:ale_set_quickfix || g:ale_set_loclist
    6   0.001445   0.000044         call ale#list#SetLists(a:buffer, a:loclist)
    6              0.000002     endif
                            
    6              0.000014     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    6              0.000002     endif
                            
    6              0.000005     if g:ale_set_highlights
    6   0.001405   0.000066         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    6              0.000003     endif
                            
    6              0.000005     if l:linting_is_done
    6              0.000007         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    6   0.001351   0.000056             call ale#cursor#EchoCursorWarning()
    6              0.000003         endif
                            
    6              0.000006         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    6              0.000016         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    6              0.000052         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    6              0.000063         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    6   0.003271   0.000151         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    6   0.000302   0.000245         silent doautocmd <nomodeline> User ALELintPost
    6              0.000005     endif

FUNCTION  ale#fixers#eslint#ProcessFixDryRunOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/eslint.vim line 17
Called 3 times
Total time:   0.000491
 Self time:   0.000092

count  total (s)   self (s)
    3   0.000457   0.000058     for l:item in ale#util#FuzzyJSONDecode(a:output, [])
    3              0.000027         return split(get(l:item, 'output', ''), "\n")
                                endfor
                            
                                return []

FUNCTION  232()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 193
Called 48 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   48              0.000112     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
   48              0.000018     endif
   48              0.000042     return s:NERDTree._PathFilters

FUNCTION  235()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim line 211
Called 2 times
Total time:   0.013402
 Self time:   0.000017

count  total (s)   self (s)
    2   0.013401   0.000016     call self.ui.render()

FUNCTION  237()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 25
Called 2 times
Total time:   0.000239
 Self time:   0.000232

count  total (s)   self (s)
    2   0.000014   0.000011     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    2   0.000020   0.000016     elseif !self.isMinimal()
                                    let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
    2              0.000001     endif

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 117
Called 3 times
Total time:   0.000127
 Self time:   0.000081

count  total (s)   self (s)
    3              0.000008     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
    6              0.000006     for l:item in a:sublist
    3   0.000071   0.000024         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
    3              0.000004         if l:item_priority > l:priority
    3              0.000004             let l:priority = l:item_priority
    3              0.000001         endif
    6              0.000005     endfor
                            
    3              0.000004     if l:priority is# g:ale#util#error_priority
    3              0.000003         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>52_CommentLinesToggle()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1072
Called 1 time
Total time:   0.026766
 Self time:   0.003537

count  total (s)   self (s)
    1              0.000002     let currentLine = a:firstLine
                            
    1              0.000002     let align = g:NERDDefaultAlign
    1   0.001383   0.000015     let leftAlignIndx = align ==# 'start' ? 0 : s:LeftMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)
    1   0.001063   0.000013     let rightAlignIndx = s:RightMostIndx(a:forceNested, 0, a:firstLine, a:lastLine)
    1   0.000035   0.000012     let rightAlignIndx = rightAlignIndx + strlen(s:Left({'space': 1}))
                            
   21              0.000032     while currentLine <= a:lastLine
                            
                                    " get the next line, check commentability and convert spaces to tabs
   20              0.000057         let theLine = getline(currentLine)
   20   0.000687   0.000353         let lineHasLeadingTabs = s:HasLeadingTabs(theLine)
   20   0.000655   0.000311         let theLine = s:ConvertLeadingTabsToSpaces(theLine)
   20   0.014049   0.000266         if s:CanToggleCommentLine(a:forceNested, currentLine)
                            
                                        "if the user has specified forceNesting then we check to see if we
                                        "need to switch delimiters for place-holders
   20   0.000321   0.000265             if g:NERDUsePlaceHolders && !s:Nested()
   20   0.005814   0.000358                 let theLine = s:SwapOuterMultiPartDelimsForPlaceHolders(theLine)
   20              0.000013             endif
                            
   20              0.000059             if align ==# 'left' || align ==# 'start' || align ==# 'both'
                                            let theLine = s:AddLeftDelimAligned(s:Left({'space': 1}), theLine, leftAlignIndx)
   20              0.000013             else
   20   0.000988   0.000401                 let theLine = s:AddLeftDelim(s:Left({'space': 1}), theLine)
   20              0.000014             endif
   20              0.000045             if align ==# 'both'
                                            let theLine = s:AddRightDelimAligned(s:Right({'space': 1}), theLine, rightAlignIndx)
   20              0.000012             else
   20   0.000683   0.000454                 let theLine = s:AddRightDelim(s:Right({'space': 1}), theLine)
   20              0.000012             endif
   20              0.000011         endif
                            
                                    " restore leading tabs if appropriate
   20              0.000022         if lineHasLeadingTabs
                                        let theLine = s:ConvertLeadingSpacesToTabs(theLine)
   20              0.000012         endif
                            
   20              0.000046         if g:NERDTrimTrailingWhitespace ==# 1
                                        let theLine = s:TrimTrailingWhitespace(theLine)
   20              0.000008         endif
                            
                                    " we are done with this line
   20              0.000311         call setline(currentLine, theLine)
   20              0.000040         let currentLine = currentLine + 1
   21              0.000020     endwhile
                            

FUNCTION  <SNR>4_SynSet()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/syntax/synload.vim line 33
Called 2 times
Total time:   0.001682
 Self time:   0.001682

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000010   syn clear
    2              0.000006   if exists("b:current_syntax")
                                unlet b:current_syntax
    2              0.000001   endif
                            
    2              0.000005   let s = expand("<amatch>")
    2              0.000003   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    2              0.000002   elseif s == "OFF"
                                let s = ""
    2              0.000001   endif
                            
    2              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000020     for name in split(s, '\.')
    2              0.001600       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.000004     endfor
    2              0.000001   endif

FUNCTION  coc#util#valid_state()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 155
Called 4 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    4              0.000047   if s:is_vim && mode() !=# 'n'
                                return 0
    4              0.000006   endif
    4              0.000021   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
    4              0.000003   endif
    4              0.000004   return 1

FUNCTION  <SNR>31_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 155
Called 93 times
Total time:   0.008120
 Self time:   0.007560

count  total (s)   self (s)
   93   0.001834   0.001274   let channel = coc#client#get_channel(self)
   93              0.000171   if empty(channel)
                                return ''
   93              0.000049   endif
   93              0.000081   try
   93              0.000072     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   93              0.000064     else
   93              0.002651       call call('rpcnotify', [channel, a:method] + a:args)
   93              0.000124     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   93              0.000091   endtry

FUNCTION  <SNR>52_HasLeadingTabs()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2457
Called 20 times
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
   40              0.000102     for s in a:000
   20              0.000085         if s =~# '^\t.*'
                                        return 1
   20              0.000013         end
   40              0.000037     endfor
   20              0.000016     return 0

FUNCTION  242()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 264
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003     return self._showBookmarks

FUNCTION  243()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 269
Called 48 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   48              0.000047     return self._showFiles

FUNCTION  244()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 274
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return self._showHelp

FUNCTION  245()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 279
Called 48 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   48              0.000045     return self._showHidden

FUNCTION  132()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim line 310
Called 2 times
Total time:   0.012166
 Self time:   0.000019

count  total (s)   self (s)
    2   0.012165   0.000018     return self._renderToString(0, 0)

FUNCTION  248()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 302
Called 64 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   64              0.000058     return self._ignoreEnabled ==# 1

FUNCTION  249()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 307
Called 6 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    6              0.000007     return g:NERDTreeMinimalUI

FUNCTION  <SNR>169_ag_handler()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 670
Called 1 time
Total time:   0.000501
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000002   if len(a:lines) < 2
                                return
    1              0.000000   endif
                            
    1   0.000021   0.000009   let cmd = s:action_for(a:lines[0], 'e')
    1   0.000089   0.000018   let list = map(filter(a:lines[1:], 'len(v:val)'), 's:ag_to_qf(v:val, a:has_column)')
    1              0.000002   if empty(list)
                                return
    1              0.000000   endif
                            
    1              0.000001   let first = list[0]
    1              0.000001   try
    1   0.000339   0.000009     call s:open(cmd, first.filename)
                                execute first.lnum
                                if a:has_column
                                  execute 'normal!' first.col.'|'
                                endif
                                normal! zz
    1              0.000013   catch
    1              0.000002   endtry
                            
    1   0.000019   0.000009   call s:fill_quickfix(list)

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 94
Called 15 times
Total time:   0.010071
 Self time:   0.003547

count  total (s)   self (s)
   15              0.000030     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
   15              0.000006     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
   15              0.001242     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
   15              0.000055     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   15              0.001654     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   15   0.000577   0.000197     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   15   0.006356   0.000212     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   15              0.000045     return 1

FUNCTION  <SNR>41_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim line 522
Called 68 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
   68              0.000095   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
   68              0.000039   else
   68              0.000073     let artifactFix = ''
   68              0.000029   endif
                            
   68              0.000064   return artifactFix

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim line 62
Called 25 times
Total time:   0.007225
 Self time:   0.002224

count  total (s)   self (s)
   25              0.000286     let l:buffer = bufnr('')
                            
   25              0.000090     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   25              0.000026     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   25              0.000093     if mode(1) isnot# 'n'
                                    return
   25              0.000012     endif
                            
   25   0.003842   0.000420     if ale#ShouldDoNothing(l:buffer)
    1              0.000001         return
   24              0.000009     endif
                            
   24   0.002005   0.000425     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
   24              0.000026     if g:ale_echo_cursor
   24              0.000066         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
   24              0.000053         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
   24              0.000013         endif
   24              0.000011     endif
                            
   24              0.000027     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
   24              0.000009     endif

FUNCTION  NERDTreeGetGitStatusPrefix()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 150
Called 34 times
Total time:   0.026081
 Self time:   0.002669

count  total (s)   self (s)
   34              0.000105     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
    1              0.000002         let s:GitStatusCacheTime = localtime()
    1   0.014825   0.000018         call g:NERDTreeGitStatusRefresh()
   34              0.000017     endif
   34   0.003850   0.000205     let l:pathStr = a:path.str()
   34   0.004593   0.000379     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
   34   0.000514   0.000316     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
   34              0.000014     endif
   34              0.000197     let l:cwd = substitute(l:cwd, '\~', '\\~', 'g')
   34              0.000310     let l:pathStr = substitute(l:pathStr, l:cwd, '', '')
   34              0.000039     let l:statusKey = ''
   34              0.000030     if a:path.isDirectory
   14              0.000070         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
   20              0.000011     else
   20              0.000090         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
   34              0.000014     endif
   34   0.001009   0.000463     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  <lambda>5()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/jscs.vim line 60
Called 9 times
Total time:   0.008565
 Self time:   0.000136

count  total (s)   self (s)
    9   0.008554   0.000125 return ale#node#FindExecutable(b, 'javascript_jscs', [       'node_modules/.bin/jscs',   ])

FUNCTION  <lambda>6()
    Defined: ~/.vim/plugged/ale/ale_linters/javascript/jshint.vim line 32
Called 9 times
Total time:   0.008353
 Self time:   0.000180

count  total (s)   self (s)
    9   0.008347   0.000174 return ale#node#FindExecutable(b, 'javascript_jshint', [       'node_modules/.bin/jshint',   ])

FUNCTION  <SNR>52_ConvertLeadingTabsToSpaces()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2074
Called 102 times
Total time:   0.001432
 Self time:   0.001432

count  total (s)   self (s)
  102              0.000172     let toReturn  = a:line
  102              0.000601     while toReturn =~# '^\( *\)\t'
                                    let toReturn = substitute(toReturn, '^\( *\)\t',  '\1' . s:TabSpace() , '')
  102              0.000103     endwhile
                            
  102              0.000104     return toReturn

FUNCTION  prettier#Autoformat()
    Defined: ~/.vim/plugged/vim-prettier/autoload/prettier.vim line 38
Called 3 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    3              0.000021   let l:autoformat = g:prettier#autoformat_config_present ? prettier#IsConfigPresent(g:prettier#autoformat_config_files) : g:prettier#autoformat
                            
    3              0.000004   if l:autoformat
                                call prettier#Prettier(1, 1, line('$'), 0, { 'requirePragma': g:prettier#autoformat_require_pragma ? 'true' : 'false' })
    3              0.000002   endif

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 143
Called 6 times
Total time:   0.015270
 Self time:   0.000394

count  total (s)   self (s)
    6              0.000020     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    6              0.000008     if empty(l:info)
                                    return
    6              0.000002     endif
                            
    6              0.000006     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    6              0.000015         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    6              0.000003     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    6   0.002626   0.000093     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    6              0.000027     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    6              0.000009     if !empty(l:linter_loclist)
                                    " Add the new items.
    3              0.000006         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    3              0.000007         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    6              0.000002     endif
                            
    6   0.000751   0.000076     if ale#ShouldDoNothing(a:buffer)
                                    return
    6              0.000002     endif
                            
    6   0.011720   0.000051     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>133_LoadArgCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 338
Called 6 times
Total time:   0.000807
 Self time:   0.000807

count  total (s)   self (s)
    6              0.000005     try
    6              0.000553         let l:output = execute('function a:function')
                                catch /E123/
                                    return 0
    6              0.000006     endtry
                            
    6              0.000141     let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
    6              0.000056     let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
    6              0.000012     return len(l:arg_list)

FUNCTION  253()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 360
Called 4 times
Total time:   0.000613
 Self time:   0.000155

count  total (s)   self (s)
    4              0.000009     let win = winnr()
    4              0.000018     let self._screenState = {}
    4              0.000003     try
    4   0.000454   0.000047         call g:NERDTree.CursorToTreeWin()
    4              0.000017         let self._screenState['oldPos'] = getpos('.')
    4              0.000012         let self._screenState['oldTopLine'] = line('w0')
    4              0.000011         let self._screenState['oldWindowSize']= winwidth('')
    4   0.000076   0.000025         call nerdtree#exec(win . 'wincmd w', 1)
                                catch
    4              0.000003     endtry

FUNCTION  256()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim line 389
Called 2 times
Total time:   0.013385
 Self time:   0.000349

count  total (s)   self (s)
    2              0.000024     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    2              0.000005     let curLine = line('.')
    2              0.000004     let curCol = col('.')
    2              0.000003     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    2              0.000053     silent 1,$delete _
                            
    2   0.000251   0.000012     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    2   0.000011   0.000008     if !self.isMinimal()
                                    call setline(line('.')+1, '')
                                    call cursor(line('.')+1, col('.'))
    2              0.000001     endif
                            
    2   0.000012   0.000008     if self.getShowBookmarks()
                                    call self._renderBookmarks()
    2              0.000001     endif
                            
                                " add the 'up a dir' line
    2   0.000009   0.000007     if !self.isMinimal()
                                    call setline(line('.')+1, s:UI.UpDirLine())
                                    call cursor(line('.')+1, col('.'))
    2              0.000001     endif
                            
                                " draw the header line
    2   0.000642   0.000019     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    2              0.000016     call setline(line('.')+1, header)
    2              0.000006     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
    2   0.012215   0.000049     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    2              0.000015     silent 1,1delete _
                            
                                " restore the view
    2              0.000007     let old_scrolloff=&scrolloff
    2              0.000018     let &scrolloff=0
    2              0.000006     call cursor(topLine, 1)
    2              0.000026     normal! zt
    2              0.000004     call cursor(curLine, curCol)
    2              0.000006     let &scrolloff = old_scrolloff
                            
    2              0.000011     setlocal readonly nomodifiable

FUNCTION  <SNR>49_splittable()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 467
Called 2 times
Total time:   0.000053
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000052   0.000022   return s:present(a:dict, 'up', 'down') && &lines > 15 || s:present(a:dict, 'left', 'right') && &columns > 40

FUNCTION  <SNR>86_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/plugin/matchparen.vim line 39
Called 57 times
Total time:   0.013069
 Self time:   0.013069

count  total (s)   self (s)
                              " Remove any previous match.
   57              0.000214   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000005     silent! call matchdelete(3)
    2              0.000002     let w:paren_hl_on = 0
   57              0.000031   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   57              0.000215   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   57              0.000022   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   57              0.000134   let c_lnum = line('.')
   57              0.000129   let c_col = col('.')
   57              0.000062   let before = 0
                            
   57              0.000171   let text = getline(c_lnum)
   57              0.000988   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   57              0.000116   if empty(matches)
                                let [c_before, c] = ['', '']
   57              0.000038   else
   57              0.000217     let [c_before, c] = matches[1:2]
   57              0.000030   endif
   57              0.000822   let plist = split(&matchpairs, '.\zs[:,]')
   57              0.000174   let i = index(plist, c)
   57              0.000056   if i < 0
                                " not found, in Insert mode try character before the cursor
   55              0.000172     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    2              0.000005       let before = strlen(c_before)
    2              0.000003       let c = c_before
    2              0.000004       let i = index(plist, c)
   55              0.000031     endif
   55              0.000041     if i < 0
                                  " not found, nothing to do
   55              0.000044       return
                                endif
    2              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000002   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    2              0.000001   else
    2              0.000003     let s_flags = 'nbW'
    2              0.000003     let c2 = c
    2              0.000004     let c = plist[i - 1]
    2              0.000001   endif
    2              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    2              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000002   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    2              0.000001   endif
                            
    2              0.000011   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    2              0.000001   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    2              0.000008     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    2              0.000002     try
    2              0.000313       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    2              0.000001     endtry
    2              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    2              0.000006   let stoplinebottom = line('w$')
    2              0.000005   let stoplinetop = line('w0')
    2              0.000002   if i % 2 == 0
                                let stopline = stoplinebottom
    2              0.000001   else
    2              0.000004     let stopline = stoplinetop
    2              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000006   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    2              0.000001   else
    2              0.000009     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000001   endif
    2              0.000001   try
    2              0.007589     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    2              0.000002   endtry
                            
    2              0.000003   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000006   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000007     if exists('*matchaddpos')
    2              0.000094       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    2              0.000001     endif
    2              0.000004     let w:paren_hl_on = 1
    2              0.000001   endif

FUNCTION  xolox#session#auto_unlock()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim line 526
Called 1 time
Total time:   0.000837
 Self time:   0.000798

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.000054   0.000015   if xolox#session#locking_enabled()
    1              0.000002     let i = 0
    2              0.000006     while i < len(s:lock_files)
    1              0.000003       let lock_file = s:lock_files[i]
    1              0.000745       if delete(lock_file) == 0
    1              0.000009         call remove(s:lock_files, i)
                                  else
                                    let i += 1
    1              0.000001       endif
    2              0.000002     endwhile
    1              0.000001   endif

FUNCTION  ale#fix#ApplyQueuedFixes()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 5
Called 9 times
Total time:  32.491420
 Self time:   0.015076

count  total (s)   self (s)
    9              0.000045     let l:data = get(g:ale_fix_buffer_data, a:buffer, {'done': 0})
                            
    9   0.000122   0.000097     if !l:data.done || (!ale#util#HasBuflineApi() && a:buffer isnot bufnr(''))
    6              0.000005         return
    3              0.000002     endif
                            
    3              0.000025     call remove(g:ale_fix_buffer_data, a:buffer)
                            
    3              0.000002     if l:data.changes_made
    2  32.417711   0.000024         let l:new_lines = ale#util#SetBufferContents(a:buffer, l:data.output)
                            
    2              0.000002         if l:data.should_save
    2              0.000005             if a:buffer is bufnr('')
    2              0.000006                 if empty(&buftype)
    2              0.014188                     noautocmd :w!
                                            else
                                                set nomodified
    2              0.000002                 endif
                                        else
                                            call writefile(l:new_lines, expand('#' . a:buffer . ':p')) " no-custom-checks
                                            call setbufvar(a:buffer, '&modified', 0)
    2              0.000001             endif
    2              0.000001         endif
    3              0.000001     endif
                            
    3              0.000007     if l:data.should_save
    3   0.000161   0.000077         let l:should_lint = ale#Var(a:buffer, 'fix_on_save')   && ale#Var(a:buffer, 'lint_on_save')
                                else
                                    let l:should_lint = l:data.changes_made
    3              0.000001     endif
                            
    3   0.000384   0.000325     silent doautocmd <nomodeline> User ALEFixPost
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
    3   0.000120   0.000089     if g:ale_enabled&& l:should_lint&& !ale#events#QuitRecently(a:buffer)
    3   0.058498   0.000042         call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
    3              0.000001     endif

FUNCTION  ale#history#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim line 8
Called 18 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
   18              0.000167     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>131_AlternatePair()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 133
Called 1 time
Total time:   0.000133
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000003   let [pat, l:for] = ['[][(){};]', 2]
    1   0.000082   0.000009   while s:SearchLoop(pat,'bW','s:SkipFunc()')
    1   0.000026   0.000023     if s:LookingAt() == ';'
                                  if !l:for
                                    if s:GetPair('{','}','bW','s:SkipFunc()')
                                      return
                                    endif
                                    break
                                  else
                                    let [pat, l:for] = ['[{}();]', l:for - 1]
                                  endif
    1              0.000001     else
    1   0.000010   0.000008       let idx = stridx('])}',s:LookingAt())
    1              0.000001       if idx == -1
    1              0.000001         return
                                  elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                    break
                                  endif
                                endif
                              endwhile
                              throw 'out of bounds'

FUNCTION  265()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/event.vim line 6
Called 34 times
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
   34              0.000096     let newObj = copy(self)
   34              0.000054     let newObj.nerdtree = a:nerdtree
   34              0.000047     let newObj.subject = a:subject
   34              0.000045     let newObj.action = a:action
   34              0.000041     let newObj.params = a:params
   34              0.000029     return newObj

FUNCTION  267()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim line 14
Called 34 times
Total time:   0.045420
 Self time:   0.002459

count  total (s)   self (s)
   34   0.000595   0.000243     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  102   0.000766   0.000296     for Listener in s:Notifier.GetListenersForEvent(a:event)
   68              0.000509     	let Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
   68   0.043196   0.001057         call Callback(event)
  102              0.000119     endfor

FUNCTION  268()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim line 23
Called 34 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   34              0.000084     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
   34              0.000015     endif
   34              0.000031     return s:refreshListenersMap

FUNCTION  269()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim line 30
Called 34 times
Total time:   0.000470
 Self time:   0.000288

count  total (s)   self (s)
   34   0.000363   0.000182     let listenersMap = s:Notifier.GetListenersMap()
   34              0.000089     return get(listenersMap, a:name, [])

FUNCTION  <SNR>52_IsCommentedFromStartOfLine()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2515
Called 42 times
Total time:   0.004525
 Self time:   0.001985

count  total (s)   self (s)
   42   0.001353   0.000755     let theLine = s:ConvertLeadingTabsToSpaces(a:line)
   42              0.000505     let numSpaces = strlen(substitute(theLine, '^\( *\).*$', '\1', ''))
   42   0.002571   0.000628     let delimIndx = s:FindDelimiterIndex(a:left, theLine)
   42              0.000054     return delimIndx ==# numSpaces

FUNCTION  <SNR>162_trim()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 16
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012   return substitute(a:line, '^\s*\|\s*$', '', 'g')

FUNCTION  <SNR>52_Left()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2806
Called 166 times
Total time:   0.003365
 Self time:   0.003256

count  total (s)   self (s)
  166              0.000325     let params = a:0 ? a:1 : {}
                            
  166              0.000620     let delim = has_key(params, 'alt') ? b:NERDCommenterDelims['leftAlt'] : b:NERDCommenterDelims['left']
                            
  166              0.000185     if delim ==# ''
                                    return ''
  166              0.000077     endif
                            
  166              0.000336     if has_key(params, 'space') && g:NERDSpaceDelims
                                    let delim = delim . s:spaceStr
  166              0.000069     endif
                            
  166              0.000245     if has_key(params, 'esc')
   21   0.000281   0.000172         let delim = s:Esc(delim)
  166              0.000070     endif
                            
  166              0.000130     return delim

FUNCTION  <SNR>159_CloseWindowIfNeeded()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim line 201
Called 6 times
Total time:   0.000281
 Self time:   0.000121

count  total (s)   self (s)
    6   0.000273   0.000114     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    6              0.000004         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  <SNR>49_fzf_exec()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 148
Called 2 times
Total time:   0.001218
 Self time:   0.001151

count  total (s)   self (s)
    2              0.000006   if !exists('s:exec')
    1              0.001086     if executable(s:fzf_go)
    1              0.000007       let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return s:fzf_exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
    1              0.000001     endif
    2              0.000001   endif
    2   0.000085   0.000019   return fzf#shellescape(s:exec)

FUNCTION  <SNR>52_IsInSexyComment()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2681
Called 21 times
Total time:   0.008007
 Self time:   0.000390

count  total (s)   self (s)
   21   0.007999   0.000382     return !empty(s:FindBoundingLinesOfSexyCom(a:line))

FUNCTION  <SNR>28_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 159
Called 93 times
Total time:   0.013438
 Self time:   0.002132

count  total (s)   self (s)
   93              0.000525   if !get(g:,'coc_workspace_initialized', 0)
                                return
   93              0.000080   endif
   93   0.012549   0.001242   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  277()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 733
Called 1 time
Total time:   0.000515
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000514   0.000014     return s:ag_handler(a:lines, self.column)

FUNCTION  279()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 694
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000000     endif

FUNCTION  coc#util#set_buf_var()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 981
Called 5 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    5              0.000038   if !bufloaded(a:bufnr) | return | endif
    5              0.000075   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  xolox#session#locking_enabled()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim line 1049
Called 1 time
Total time:   0.000039
 Self time:   0.000021

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    1   0.000030   0.000012   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 51
Called 6 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    6              0.000046     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
    6              0.000018     endif
                            
                                " When entering a buffer, we are no longer quitting it.
    6              0.000034     call setbufvar(a:buffer, 'ale_quitting', 0)
    6              0.000027     let l:filetype = getbufvar(a:buffer, '&filetype')
    6              0.000027     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    6              0.000015     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
    6              0.000003     endif

FUNCTION  xolox#misc#option#get()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/option.vim line 7
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    1              0.000005   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
    1              0.000003   elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
    1              0.000002   elseif exists('a:1')
                                " Default value.
    1              0.000001     return a:1
                              endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim line 523
Called 72 times
Total time:   0.097269
 Self time:   0.001862

count  total (s)   self (s)
   72              0.000534     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
   72   0.096643   0.001236     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>52_Multipart()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2872
Called 21 times
Total time:   0.000510
 Self time:   0.000235

count  total (s)   self (s)
   21   0.000503   0.000228     return s:Right() !=# ''

FUNCTION  <SNR>162_is_jsx_expression()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 72
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   return a:syntax =~? 'jsxExpressionBlock'

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim line 175
Called 15 times
Total time:   0.001134
 Self time:   0.000922

count  total (s)   self (s)
   15   0.000363   0.000151     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   15              0.000082     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
   15              0.000035     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
   15              0.000011     endif
                            
   15              0.000045     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
   15              0.000007     endif
                            
   15              0.000126     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
   15              0.000006     endif
                            
   15              0.000237     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 82
Called 79 times
Total time:   0.000632
 Self time:   0.000632

count  total (s)   self (s)
   79              0.000249     if type(a:string_or_ref) is v:t_string
   12              0.000032         return function(a:string_or_ref)
   67              0.000049     endif
                            
   67              0.000071     return a:string_or_ref

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim line 295
Called 15 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   15              0.000024     let l:clear_tempdir = 0
                            
   15              0.000082     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
   15              0.000006     endif
                            
   15              0.000010     try
   15              0.000046         let l:name = tempname() " no-custom-checks
   15              0.000015     finally
   15              0.000014         if l:clear_tempdir
                                        let $TMPDIR = ''
   15              0.000007         endif
   15              0.000010     endtry
                            
   15              0.000016     return l:name

FUNCTION  <SNR>158_UpdateLineNumbers()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 256
Called 6 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
    6              0.000009     let l:line_map = {}
    6              0.000008     let l:line_numbers_changed = 0
                            
    9              0.000017     for [l:line, l:sign_id, l:name] in a:current_sign_list
    3              0.000007         let l:line_map[l:sign_id] = l:line
    9              0.000007     endfor
                            
    9              0.000010     for l:item in a:loclist
    3              0.000004         if l:item.bufnr == a:buffer
    3              0.000011             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
    3              0.000004             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
    3              0.000001             endif
    3              0.000001         endif
    9              0.000010     endfor
                            
                                " When the line numbers change, sort the list again
    6              0.000006     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    6              0.000002     endif

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 99
Called 93 times
Total time:   0.011307
 Self time:   0.002356

count  total (s)   self (s)
   93   0.001690   0.000859   if !coc#rpc#ready()
                                return ''
   93              0.000038   endif
   93   0.009314   0.001194   call s:client['notify'](a:method, a:args)
   93              0.000098   return ''

FUNCTION  ale#sign#ReadSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 170
Called 6 times
Total time:   0.000327
 Self time:   0.000288

count  total (s)   self (s)
    6              0.000024     redir => l:output
    6   0.000245   0.000207         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
    6              0.000016     redir end
                            
    6              0.000033     return split(l:output, "\n")

FUNCTION  <SNR>169_fzf()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim line 215
Called 2 times
Total time:   0.066375
 Self time:   0.000174

count  total (s)   self (s)
    2              0.000008   let [extra, bang] = [{}, 0]
    2              0.000004   if len(a:extra) <= 1
                                let first = get(a:extra, 0, 0)
                                if type(first) == s:TYPE.dict
                                  let extra = first
                                else
                                  let bang = first
                                endif
    2              0.000003   elseif len(a:extra) == 2
    2              0.000004     let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
    2              0.000001   endif
                            
    2              0.000009   let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
    2              0.000019   let merged = extend(copy(a:opts), extra)
    2   0.000093   0.000017   call s:merge_opts(merged, eopts)
    2   0.066210   0.000086   return fzf#run(s:wrap(a:name, merged, bang))

FUNCTION  <SNR>49_calc_size()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 618
Called 2 times
Total time:   0.000242
 Self time:   0.000227

count  total (s)   self (s)
    2              0.000018   let val = substitute(a:val, '^\~', '', '')
    2              0.000009   if val =~ '%$'
    2              0.000008     let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
    2              0.000001   endif
                            
    2              0.000003   let srcsz = -1
    2              0.000009   if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
    2              0.000001   endif
                            
    2   0.000044   0.000030   let opts = $FZF_DEFAULT_OPTS.' '.s:evaluate_opts(get(a:dict, 'options', ''))
    2              0.000099   let margin = match(opts, '--inline-info\|--info[^-]\{-}inline') > match(opts, '--no-inline-info\|--info[^-]\{-}\(default\|hidden\)') ? 1 : 2
    2              0.000013   let margin += stridx(opts, '--border') > stridx(opts, '--no-border') ? 2 : 0
    2              0.000008   if stridx(opts, '--header') > stridx(opts, '--no-header')
                                let margin += len(split(opts, "\n"))
    2              0.000001   endif
    2              0.000006   return srcsz >= 0 ? min([srcsz + margin, size]) : size

FUNCTION  <SNR>52_HasCStyleComments()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2467
Called 21 times
Total time:   0.001887
 Self time:   0.000737

count  total (s)   self (s)
   21   0.001877   0.000728     return (s:Left() ==# '/*' && s:Right() ==# '*/') || (s:Left({'alt': 1}) ==# '/*' && s:Right({'alt': 1}) ==# '*/')

FUNCTION  <SNR>52_RecoverStateAfterLineComment()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1611
Called 1 time
Total time:   0.000022
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000004     if a:state['foldmethod'] !=# &foldmethod
    1   0.000008   0.000007         let &foldmethod = a:state['foldmethod']
    1              0.000000     endif
    1              0.000002     if a:state['ignorecase'] !=# &ignorecase
    1   0.000006   0.000004         let &ignorecase = a:state['ignorecase']
    1              0.000000     endif

FUNCTION  <SNR>158_GroupLoclistItems()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 235
Called 6 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    6              0.000008     let l:grouped_items = []
    6              0.000007     let l:last_lnum = -1
                            
    9              0.000010     for l:obj in a:loclist
    3              0.000004         if l:obj.bufnr != a:buffer
                                        continue
    3              0.000001         endif
                            
                                    " Create a new sub-List when we hit a new line.
    3              0.000003         if l:obj.lnum != l:last_lnum
    3              0.000006             call add(l:grouped_items, [])
    3              0.000001         endif
                            
    3              0.000007         call add(l:grouped_items[-1], l:obj)
    3              0.000004         let l:last_lnum = l:obj.lnum
    9              0.000012     endfor
                            
    6              0.000006     return l:grouped_items

FUNCTION  <SNR>160_matchaddpos()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim line 89
Called 5 times
Total time:   0.000392
 Self time:   0.000252

count  total (s)   self (s)
    5              0.000006     if s:has_nvim_highlight
   10              0.000013         for l:pos in a:pos_list
    5              0.000018             let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
    5              0.000013             if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
    5              0.000003             else
    5              0.000008                 let l:col_start = l:pos[1] - 1
    5              0.000011                 let l:col_end = l:col_start + get(l:pos, 2, 1)
    5              0.000002             endif
                            
    5   0.000198   0.000059             call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
   10              0.000013         endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
    5              0.000002     endif

FUNCTION  <SNR>52_AltMultipart()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 1950
Called 21 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   21              0.000049     return b:NERDCommenterDelims['rightAlt'] !=# ''

FUNCTION  nerdtree#renderView()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 255
Called 2 times
Total time:   0.013429
 Self time:   0.000027

count  total (s)   self (s)
    2   0.013428   0.000026     call b:NERDTree.render()

FUNCTION  <SNR>52_IsDelimValid()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim line 2582
Called 2 times
Total time:   0.000460
 Self time:   0.000102

count  total (s)   self (s)
                                "get the delimiter without the escchars
    2              0.000003     let l:delimiter = a:delimiter
                            
                                "get the strings before and after the delimiter
    2              0.000006     let preComStr = strpart(a:line, 0, a:delIndx)
    2              0.000008     let postComStr = strpart(a:line, a:delIndx+strlen(delimiter))
                            
                                "to check if the delimiter is real, make sure it isn't preceded by
                                "an odd number of quotes and followed by the same (which would indicate
                                "that it is part of a string and therefore is not a comment)
    2   0.000433   0.000075     if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\")) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, '"', '\\'))
    2              0.000001         return 0
                                endif
                                if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, "'", '\\')) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, "'", '\\'))
                                    return 0
                                endif
                                if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '`', '\\')) && !s:IsNumEven(s:CountNonESCedOccurances(postComStr, '`', '\\'))
                                    return 0
                                endif
                            
                            
                                "if the comment delimiter is escaped, assume it isn't a real delimiter
                                if s:IsEscaped(a:line, a:delIndx, "\\")
                                    return 0
                                endif
                            
                                "vim comments are so fucking stupid!! Why the hell do they have comment
                                "delimiters that are used elsewhere in the syntax?!?! We need to check
                                "some conditions especially for vim
                                if &filetype ==# 'vim'
                                    if !s:IsNumEven(s:CountNonESCedOccurances(preComStr, '"', "\\"))
                                        return 0
                                    endif
                            
                                    "if the delimiter is on the very first char of the line or is the
                                    "first non-tab/space char on the line then it is a valid comment delimiter
                                    if a:delIndx ==# 0 || a:line =~# "^[ \t]\\{" . a:delIndx . "\\}\".*$"
                                        return 1
                                    endif
                            
                                    let numLeftParen =s:CountNonESCedOccurances(preComStr, '(', '\\')
                                    let numRightParen =s:CountNonESCedOccurances(preComStr, ')', '\\')
                            
                                    "if the quote is inside brackets then assume it isn't a comment
                                    if numLeftParen > numRightParen
                                        return 0
                                    endif
                            
                                    "if the line has an even num of unescaped "'s then we can assume that
                                    "any given " is not a comment delimiter
                                    if s:IsNumEven(s:CountNonESCedOccurances(a:line, '"', '\\'))
                                        return 0
                                    endif
                                endif
                            
                                return 1
                            

FUNCTION  <SNR>144_StopCurrentJobs()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 547
Called 9 times
Total time:   0.000778
 Self time:   0.000312

count  total (s)   self (s)
    9              0.000033     let l:info = get(g:ale_buffer_info, a:buffer, {})
    9   0.000542   0.000123     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    9              0.000013     if a:clear_lint_file_jobs
    3   0.000066   0.000020         call ale#command#StopJobs(a:buffer, 'file_linter')
    3              0.000012         let l:info.active_linter_list = []
    6              0.000004     else
                                    " Keep jobs for linting files when we're only linting buffers.
    6              0.000048         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
    9              0.000005     endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 67
Called 12 times
Total time:   0.004860
 Self time:   0.004700

count  total (s)   self (s)
   12              0.000050     let l:info = get(s:buffer_data, a:buffer, {})
                            
   12              0.000030     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    9   0.000226   0.000066         if ale#util#InSandbox()
                                        return
    9              0.000004         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    9              0.000019         for l:filename in l:info.file_list
                                        call delete(l:filename)
    9              0.000009         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
   24              0.000040         for l:directory in l:info.directory_list
   15              0.004190             call delete(l:directory, 'rf')
   24              0.000050         endfor
                            
    9              0.000036         call remove(s:buffer_data, a:buffer)
   12              0.000006     endif

FUNCTION  <SNR>144_RunLinter()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 656
Called 81 times
Total time:   0.174019
 Self time:   0.002781

count  total (s)   self (s)
   81              0.000201     if !empty(a:linter.lsp)
   18   0.024112   0.000223         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
   63              0.000039     else
   63   0.091182   0.000890         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   63   0.058230   0.001173         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  <SNR>49_has_any()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 206
Called 4 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   20              0.000023   for key in a:keys
   16              0.000032     if has_key(a:dict, key)
                                  return 1
   16              0.000007     endif
   20              0.000013   endfor
    4              0.000003   return 0

FUNCTION  ale#fix#registry#GetFunc()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix/registry.vim line 444
Called 6 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
                                " Use the exact name, or an alias.
    6              0.000066     let l:resolved_name = !has_key(s:entries, a:name)   ? get(s:aliases, a:name, a:name)   : a:name
                            
    6              0.000067     return get(s:entries, l:resolved_name, {'function': ''}).function

FUNCTION  <SNR>49_callback()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 779
Called 1 time
Total time:   0.000839
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000003   let popd = has_key(a:dict, 'pushd')
    1              0.000001   if popd
    1              0.000002     let w:fzf_pushd = a:dict.pushd
    1              0.000001   endif
                            
    1              0.000001   try
    1              0.000002     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
    1              0.000001     endif
    1              0.000002     if has_key(a:dict, 'sink*')
    1   0.000521   0.000006       call a:dict['sink*'](a:lines)
    1              0.000001     endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
    1              0.000001   endtry
                            
                              " We may have opened a new window or tab
    1              0.000001   if popd
    1              0.000002     let w:fzf_pushd = a:dict.pushd
    1   0.000285   0.000006     call s:dopopd()
    1              0.000000   endif

FUNCTION  <SNR>164_RunFixer()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim line 207
Called 9 times
Total time:  32.543058
 Self time:   0.001002

count  total (s)   self (s)
    9              0.000024     let l:buffer = a:options.buffer
    9              0.000012     let l:input = a:options.input
    9              0.000011     let l:index = a:options.callback_index
                            
    9              0.000022     if len(a:options.callback_list) <= l:index
    3  32.493993   0.000273         call ale#fix#ApplyFixes(l:buffer, l:input)
                            
    3              0.000002         return
    6              0.000003     endif
                            
    6              0.000021     let l:ChainCallback = get(a:options, 'chain_callback', v:null)
                            
    6              0.000035     let l:Function = l:ChainCallback isnot v:null   ? ale#util#GetFunction(l:ChainCallback)   : a:options.callback_list[l:index]
                            
                                " Record new jobs started as fixer jobs.
    6              0.000025     call setbufvar(l:buffer, 'ale_job_type', 'fixer')
                            
    6              0.000008     if l:ChainCallback isnot v:null
                                    " Chained commands accept (buffer, output, [input])
                                    let l:result = ale#util#FunctionArgCount(l:Function) == 2   ? call(l:Function, [l:buffer, a:options.output])   : call(l:Function, [l:buffer, a:options.output, copy(l:input)])
    6              0.000004     else
                                    " Regular fixer commands accept (buffer, [input])
    6   0.028320   0.000213         let l:result = ale#util#FunctionArgCount(l:Function) == 1   ? call(l:Function, [l:buffer])   : call(l:Function, [l:buffer, copy(l:input)])
    6              0.000004     endif
                            
    6   0.020449   0.000221     call s:RunJob(l:result, {   'buffer': l:buffer,   'input': l:input,   'callback_list': a:options.callback_list,   'callback_index': l:index,})

FUNCTION  <SNR>104_gcd()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow_main.vim line 64
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000007 	let [a, b, t] = [a:a, a:b, 0]
    4              0.000004 	while b != 0
    2              0.000002 		let t = b
    2              0.000002 		let b = a % b
    2              0.000001 		let a = t
    4              0.000004 	endwhile
    2              0.000002 	return a

FUNCTION  GetJavascriptIndent()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 352
Called 1 time
Total time:   0.000595
 Self time:   0.000346

count  total (s)   self (s)
    1   0.000023   0.000008   call s:GetVars()
    1              0.000010   let s:synid_cache = [[],[]]
    1              0.000003   let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
    1              0.000061   let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
    1              0.000006   if s:stack[-1] =~? 'comment\|doc'
                                if l:line =~ '^\s*\*'
                                  return cindent(v:lnum)
                                elseif l:line !~ '^\s*\/[/*]'
                                  return -1
                                endif
    1              0.000005   elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
    1              0.000000   endif
                            
    1              0.000008   let s:l1 = max([0,prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), get(get(b:,'hi_indent',{}),'blocklnr')])
    1              0.000002   call cursor(v:lnum,1)
    1   0.000102   0.000011   if s:PreviousToken() is ''
                                return
    1              0.000000   endif
    1              0.000005   let [l:lnum, pline] = [line('.'), getline('.')[:col('.')-1]]
                            
    1              0.000006   let l:line = substitute(l:line,'^\s*','','')
    1              0.000001   let l:line_raw = l:line
    1              0.000001   if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
    1              0.000000   endif
    1              0.000003   if l:line =~ '^\/[/*]'
                                let l:line = ''
    1              0.000000   endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    1              0.000002   call cursor(v:lnum,1)
    1              0.000004   let idx = index([']',')','}'],l:line[0])
    1              0.000004   if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum || b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
    1              0.000000   else
    1              0.000021     let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0, max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
    1              0.000001     try
    1              0.000001       if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
    1              0.000009       elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    call s:GetPair('{','}','bW','s:SkipFunc()')
    1              0.000000       else
    1   0.000142   0.000009         call s:AlternatePair()
    1              0.000001       endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
    1              0.000001     endtry
    1              0.000007     let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
    1              0.000000   endif
                            
    1              0.000003   let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
    1   0.000013   0.000011   let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
    1   0.000010   0.000007   if !num || s:LookingAt() == '{' && s:IsBlock()
                                let ilnum = line('.')
                                if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
                                endif
                                if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, len(pline))
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum, 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' && s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) && s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) && (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' && s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, len(pline))
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
                                endif
    1   0.000018   0.000016   elseif idx.s:LookingAt().&cino =~ '^-1(.*(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m\S','W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
    1              0.000001   endif
                            
                              " main return
    1              0.000004   if l:line =~ '^[])}]\|^|}'
                                if l:line_raw[0] == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
    1              0.000001   elseif num
    1   0.000017   0.000013     return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              endif
                              return b_l + is_op

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim line 187
Called 15 times
Total time:   0.000542
 Self time:   0.000437

count  total (s)   self (s)
   15              0.000052     let l:info = get(s:buffer_data, a:buffer, {})
                            
   15              0.000022     if !empty(l:info)
    3              0.000003         let l:new_map = {}
                            
    6              0.000033         for [l:job_id, l:job_type] in items(l:info.jobs)
    3              0.000007             let l:job_id = str2nr(l:job_id)
                            
    3              0.000007             if a:job_type is# 'all' || a:job_type is# l:job_type
    3   0.000130   0.000024                 call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
    3              0.000002             endif
    6              0.000007         endfor
                            
    3              0.000022         let l:info.jobs = l:new_map
   15              0.000008     endif

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 27
Called 9 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    9              0.000019     let l:found = 0
                            
    9              0.000032     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    9              0.000013     endfor
                            
    9              0.000008     if !l:found
    9              0.000023         call add(a:info.active_linter_list, a:linter)
    9              0.000004     endif

FUNCTION  <SNR>49_execute_term()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 685
Called 2 times
Total time:   0.062777
 Self time:   0.004292

count  total (s)   self (s)
    2              0.000015   let winrest = winrestcmd()
    2              0.000007   let pbuf = bufnr('')
    2   0.014768   0.000043   let [ppos, winopts] = s:split(a:dict)
    2   0.000088   0.000025   call s:use_sh()
    2              0.000005   let b:fzf = a:dict
    2              0.000030   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    2              0.000006   function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
    2              0.000004   function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction
                            
    2              0.000002   try
    2   0.001053   0.000021     call s:pushd(a:dict)
    2              0.000002     if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
    2              0.000001     else
    2              0.000005       let command = a:command
    2              0.000001     endif
    2              0.000007     let command .= s:term_marker
    2              0.000008     if has('nvim')
    2   0.004794   0.003481       call termopen(command, fzf)
                                else
                                  if !len(&bufhidden)
                                    setlocal bufhidden=hide
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], {'curwin': 1, 'exit_cb': function(fzf.on_exit)})
                                  if !has('patch-8.0.1261') && !has('nvim') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
    2              0.000001     endif
    2              0.000003   finally
    2   0.001160   0.000124     call s:dopopd()
    2              0.000002   endtry
    2   0.005573   0.000068   setlocal nospell bufhidden=wipe nobuflisted nonumber
    2   0.034848   0.000038   setf fzf
    2              0.000019   startinsert
    2              0.000006   return []

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 416
Called 6 times
Total time:   0.003397
 Self time:   0.000604

count  total (s)   self (s)
    6              0.000016     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    6              0.000002     endif
                            
                                " Find the current markers
    6   0.001277   0.000105     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    6   0.000282   0.000099     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    6   0.000206   0.000072     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    6   0.000774   0.000064     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    6   0.000679   0.000084     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    6              0.000011     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    6              0.000002     endif
                            
   16              0.000017     for l:command in l:command_list
   10              0.000035         silent! execute l:command
   16              0.000009     endfor
                            
                                " Reset the sign column color when there are no more errors.
    6              0.000010     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    6              0.000002     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim line 103
Called 42 times
Total time:   0.002412
 Self time:   0.001816

count  total (s)   self (s)
   42              0.000177     let l:buffer = bufnr('')
                            
   42              0.000083     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   42              0.000022     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   42              0.000114     if mode(1) isnot# 'n'
   12              0.000009         return
   30              0.000011     endif
                            
   30   0.000572   0.000346     call s:StopCursorTimer()
                            
   30              0.000149     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   30              0.000066     if l:pos != s:last_pos
   23   0.000601   0.000231         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
   23              0.000090         let s:last_pos = l:pos
   23              0.000145         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
   30              0.000017     endif

FUNCTION  <SNR>131_SearchLoop()
    Defined: /usr/local/Cellar/neovim/0.4.3/share/nvim/runtime/indent/javascript.vim line 198
Called 1 time
Total time:   0.000074
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000073   0.000010   return s:GetPair(a:pat,'\_$.',a:flags,a:expr)

FUNCTION  rainbow#syn()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 51
Called 2 times
Total time:   0.007236
 Self time:   0.004379

count  total (s)   self (s)
    2              0.000003 	let conf = a:config
    2              0.000003 	let prefix = conf.syn_name_prefix
    2              0.000002 	let cycle = conf.cycle
                            
    2   0.000150   0.000020 	let glob_paran_opts = s:resolve_parenthesis_from_config(conf)
    2              0.000003 	let b:rainbow_loaded = cycle
    8              0.000013 	for id in range(len(conf.parentheses))
    6   0.001569   0.000132 		let [paren, contained, containedin, contains_prefix, contains, op] = s:resolve_parenthesis_with(glob_paran_opts, conf.parentheses[id])
   30              0.000039 		for lv in range(cycle)
   24              0.000046 			let lv2 = ((lv + cycle - 1) % cycle)
   24   0.000914   0.000641 			let [rid, pid, gid2] = [s:synID(prefix, 'r', lv, id), s:synID(prefix, 'p', lv, id), s:synGroupID(prefix, 'Regions', lv2)]
                            
   24              0.000072 			if len(op) > 2
   24   0.001010   0.000842 				exe 'syn match '.s:synID(prefix, 'o', lv, id).' '.op.' containedin='.s:synID(prefix, 'r', lv, id).' contained'
   24              0.000015 			endif
                            
   24              0.000085 			let real_contained = (lv == 0)? (contained? 'contained ' : '') : 'contained '
   24   0.000209   0.000129 			let real_containedin = (lv == 0)? s:concat([containedin, '@'.gid2]) : '@'.gid2
   24   0.000493   0.000192 			let real_contains = s:concat([contains_prefix, contains])
   24              0.000552 			exe 'syn region '.rid.' matchgroup='.pid.' '.real_contained.'containedin='.real_containedin.' contains='.real_contains.' '.paren
   30              0.000021 		endfor
    8              0.000009 	endfor
   10              0.000014 	for lv in range(cycle)
    8   0.000503   0.000357 		exe 'syn cluster '.s:synGroupID(prefix, 'Regions', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "r", lv, v:val)'), ',')
    8   0.000371   0.000275 		exe 'syn cluster '.s:synGroupID(prefix, 'Parentheses', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "p", lv, v:val)'), ',')
    8   0.000380   0.000285 		exe 'syn cluster '.s:synGroupID(prefix, 'Operators', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "o", lv, v:val)'), ',')
   10              0.000007 	endfor
    2   0.000111   0.000091 	exe 'syn cluster '.prefix.'Regions contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Regions", v:val)'), ',')
    2   0.000114   0.000089 	exe 'syn cluster '.prefix.'Parentheses contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Parentheses", v:val)'), ',')
    2   0.000247   0.000162 	exe 'syn cluster '.prefix.'Operators contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Operators", v:val)'), ',')
    2              0.000017 	if has_key(conf, 'after') | for cmd in conf.after | exe cmd | endfor | endif

FUNCTION  <SNR>105_synID()
    Defined: ~/.vim/plugged/rainbow/autoload/rainbow.vim line 43
Called 216 times
Total time:   0.000869
 Self time:   0.000869

count  total (s)   self (s)
  216              0.000793 	return a:prefix.'_lv'.a:lv.'_'.a:group.a:id

FUNCTION  <SNR>162_is_jsx_brace()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 77
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return a:syntax =~? 'jsxBraces'

FUNCTION  <SNR>162_is_jsx_element()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 67
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return a:syntax =~? 'jsxElement'

FUNCTION  fzf#run()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 368
Called 2 times
Total time:   0.064777
 Self time:   0.000495

count  total (s)   self (s)
    2              0.000005 try
    2   0.000115   0.000047   let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
    2              0.000018   let dict   = exists('a:1') ? copy(a:1) : {}
    2   0.000067   0.000040   let temps  = { 'result': s:fzf_tempname() }
    2   0.000035   0.000020   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    2              0.000002   try
    2   0.001238   0.000020     let fzf_exec = s:fzf_exec()
                              catch
                                throw v:exception
    2              0.000003   endtry
                            
    2              0.000005   if !has_key(dict, 'dir')
    2   0.000190   0.000021     let dict.dir = s:fzf_getcwd()
    2              0.000003   endif
    2              0.000013   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
    2              0.000001   endif
                            
    2              0.000004   if has_key(dict, 'source')
                                let source = dict.source
                                let type = type(source)
                                if type == 1
                                  let prefix = '( '.source.' )|'
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(map(source, '<SID>enc_to_cp(v:val)'), temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
                                endif
    2              0.000001   else
    2              0.000003     let prefix = ''
    2              0.000001   endif
                            
    2              0.000010   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
    2              0.000023   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    2              0.000009   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    2              0.000010   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    2              0.000011   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    2              0.000019   let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
    2              0.000003   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
    2              0.000001   endif
    2              0.000002   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
    2              0.000002   elseif use_term
    2              0.000005     let optstr .= ' --no-height'
    2              0.000001   endif
    2              0.000017   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    2              0.000002   if use_term
    2   0.062816   0.000039     return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
    2              0.000002 finally
    2   0.000038   0.000030   let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
    2              0.000005 endtry

FUNCTION  <SNR>158_GroupCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim line 161
Called 16 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
   16              0.000016     if s:supports_sign_groups
   16              0.000012         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <SNR>49_dopopd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim line 494
Called 9 times
Total time:   0.001343
 Self time:   0.000797

count  total (s)   self (s)
    9              0.000035   if !exists('w:fzf_pushd')
    6              0.000005     return
    3              0.000002   endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
    3   0.000127   0.000052   if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
    3   0.001127   0.000656     execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
    3              0.000002   endif
    3              0.000009   unlet w:fzf_pushd

FUNCTION  coc#util#unplace_signs()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 565
Called 8 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
    8              0.000059   if !bufloaded(a:bufnr) | return | endif
   20              0.000039   for id in a:sign_ids
   12              0.000100     execute 'silent! sign unplace '.id.' buffer='.a:bufnr
   20              0.000033   endfor

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   61  32.583360   0.004348  <SNR>150_NeoVimCallback()
   15  32.554191   0.001079  <SNR>145_ExitCallback()
    9  32.543058   0.001002  <SNR>164_RunFixer()
    6  32.525430   0.008515  <SNR>164_HandleExit()
    3  32.493720   0.000703  ale#fix#ApplyFixes()
    9  32.491420   0.015076  ale#fix#ApplyQueuedFixes()
    2  32.417687  32.417681  ale#util#SetBufferContents()
   12   0.192431   0.002477  <SNR>95_Lint()
    9   0.178492   0.003026  ale#engine#RunLinters()
   81   0.174019   0.002781  <SNR>144_RunLinter()
  183   0.130923             ale#path#FindNearestFile()
   84   0.117947   0.006243  ale#node#FindExecutable()
   72   0.097269   0.001862  ale#linter#GetExecutable()
   16   0.083831   0.001081  ale#Queue()
    9   0.077529   0.000317  <SNR>28_SyncAutocmd()
    9   0.077212   0.000248  coc#rpc#request()
    9   0.076892   0.076725  <SNR>31_request()
    2   0.066682   0.000307  fzf#vim#grep()
    2   0.066375   0.000174  <SNR>169_fzf()
    2   0.064777   0.000495  fzf#run()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2  32.417687  32.417681  ale#util#SetBufferContents()
  183              0.130923  ale#path#FindNearestFile()
    9   0.076892   0.076725  <SNR>31_request()
  255              0.033912  lightline#link()
   15   0.026936   0.026850  ale#job#Start()
   14   0.060097   0.025338  164()
   46   0.023967   0.019806  ale#util#JoinNeovimOutput()
    9  32.491420   0.015076  ale#fix#ApplyQueuedFixes()
   28   0.033120   0.013821  <SNR>96_line()
  249   0.029445   0.013416  40()
   57              0.013069  <SNR>86_Highlight_Matching_Pair()
   26   0.014293   0.012529  133()
   56   0.015770   0.011170  <SNR>96_expand()
    2   0.010973   0.010301  rainbow#load()
    2              0.009762  <SNR>26_LoadFTPlugin()
   21   0.031320   0.009703  141()
    6              0.009060  <SNR>146_CheckForBadConfig()
    6  32.525430   0.008515  <SNR>164_HandleExit()
   93   0.008120   0.007560  <SNR>31_notify()
  247   0.015079   0.007301  45()

